// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: e2sm_rmet/v1/e2sm_rmet.proto

package e2sm_rmet_go

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Eutracgi with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Eutracgi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Eutracgi with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EutracgiMultiError, or nil
// if none found.
func (m *Eutracgi) ValidateAll() error {
	return m.validate(true)
}

func (m *Eutracgi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EutracgiValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEUtracellIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "EUtracellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EutracgiValidationError{
					field:  "EUtracellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEUtracellIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EutracgiValidationError{
				field:  "EUtracellIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EutracgiMultiError(errors)
	}

	return nil
}

// EutracgiMultiError is an error wrapping multiple validation errors returned
// by Eutracgi.ValidateAll() if the designated constraints aren't met.
type EutracgiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EutracgiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EutracgiMultiError) AllErrors() []error { return m }

// EutracgiValidationError is the validation error returned by
// Eutracgi.Validate if the designated constraints aren't met.
type EutracgiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EutracgiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EutracgiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EutracgiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EutracgiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EutracgiValidationError) ErrorName() string { return "EutracgiValidationError" }

// Error satisfies the builtin error interface
func (e EutracgiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEutracgi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EutracgiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EutracgiValidationError{}

// Validate checks the field values on Nrcgi with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Nrcgi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Nrcgi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NrcgiMultiError, or nil if none found.
func (m *Nrcgi) ValidateAll() error {
	return m.validate(true)
}

func (m *Nrcgi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NrcgiValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNRcellIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "NRcellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NrcgiValidationError{
					field:  "NRcellIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNRcellIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NrcgiValidationError{
				field:  "NRcellIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NrcgiMultiError(errors)
	}

	return nil
}

// NrcgiMultiError is an error wrapping multiple validation errors returned by
// Nrcgi.ValidateAll() if the designated constraints aren't met.
type NrcgiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NrcgiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NrcgiMultiError) AllErrors() []error { return m }

// NrcgiValidationError is the validation error returned by Nrcgi.Validate if
// the designated constraints aren't met.
type NrcgiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NrcgiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NrcgiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NrcgiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NrcgiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NrcgiValidationError) ErrorName() string { return "NrcgiValidationError" }

// Error satisfies the builtin error interface
func (e NrcgiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNrcgi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NrcgiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NrcgiValidationError{}

// Validate checks the field values on CellGlobalId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellGlobalId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellGlobalId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellGlobalIdMultiError, or
// nil if none found.
func (m *CellGlobalId) ValidateAll() error {
	return m.validate(true)
}

func (m *CellGlobalId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.CellGlobalId.(type) {

	case *CellGlobalId_NrCgi:

		if all {
			switch v := interface{}(m.GetNrCgi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "NrCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "NrCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNrCgi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CellGlobalIdValidationError{
					field:  "NrCgi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CellGlobalId_EUtraCgi:

		if all {
			switch v := interface{}(m.GetEUtraCgi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "EUtraCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CellGlobalIdValidationError{
						field:  "EUtraCgi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEUtraCgi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CellGlobalIdValidationError{
					field:  "EUtraCgi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CellGlobalIdMultiError(errors)
	}

	return nil
}

// CellGlobalIdMultiError is an error wrapping multiple validation errors
// returned by CellGlobalId.ValidateAll() if the designated constraints aren't met.
type CellGlobalIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellGlobalIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellGlobalIdMultiError) AllErrors() []error { return m }

// CellGlobalIdValidationError is the validation error returned by
// CellGlobalId.Validate if the designated constraints aren't met.
type CellGlobalIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellGlobalIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellGlobalIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellGlobalIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellGlobalIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellGlobalIdValidationError) ErrorName() string { return "CellGlobalIdValidationError" }

// Error satisfies the builtin error interface
func (e CellGlobalIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellGlobalId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellGlobalIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellGlobalIdValidationError{}

// Validate checks the field values on Snssai with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Snssai) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Snssai with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SnssaiMultiError, or nil if none found.
func (m *Snssai) ValidateAll() error {
	return m.validate(true)
}

func (m *Snssai) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSSt()) != 1 {
		err := SnssaiValidationError{
			field:  "SSt",
			reason: "value length must be 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.SD != nil {

		if len(m.GetSD()) != 3 {
			err := SnssaiValidationError{
				field:  "SD",
				reason: "value length must be 3 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return SnssaiMultiError(errors)
	}

	return nil
}

// SnssaiMultiError is an error wrapping multiple validation errors returned by
// Snssai.ValidateAll() if the designated constraints aren't met.
type SnssaiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnssaiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnssaiMultiError) AllErrors() []error { return m }

// SnssaiValidationError is the validation error returned by Snssai.Validate if
// the designated constraints aren't met.
type SnssaiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnssaiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnssaiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnssaiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnssaiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnssaiValidationError) ErrorName() string { return "SnssaiValidationError" }

// Error satisfies the builtin error interface
func (e SnssaiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnssai.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnssaiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnssaiValidationError{}

// Validate checks the field values on FiveQi with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FiveQi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FiveQi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FiveQiMultiError, or nil if none found.
func (m *FiveQi) ValidateAll() error {
	return m.validate(true)
}

func (m *FiveQi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := FiveQiValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return FiveQiMultiError(errors)
	}

	return nil
}

// FiveQiMultiError is an error wrapping multiple validation errors returned by
// FiveQi.ValidateAll() if the designated constraints aren't met.
type FiveQiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FiveQiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FiveQiMultiError) AllErrors() []error { return m }

// FiveQiValidationError is the validation error returned by FiveQi.Validate if
// the designated constraints aren't met.
type FiveQiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FiveQiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FiveQiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FiveQiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FiveQiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FiveQiValidationError) ErrorName() string { return "FiveQiValidationError" }

// Error satisfies the builtin error interface
func (e FiveQiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFiveQi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FiveQiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FiveQiValidationError{}

// Validate checks the field values on Qci with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Qci) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Qci with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QciMultiError, or nil if none found.
func (m *Qci) ValidateAll() error {
	return m.validate(true)
}

func (m *Qci) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := QciValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QciMultiError(errors)
	}

	return nil
}

// QciMultiError is an error wrapping multiple validation errors returned by
// Qci.ValidateAll() if the designated constraints aren't met.
type QciMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QciMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QciMultiError) AllErrors() []error { return m }

// QciValidationError is the validation error returned by Qci.Validate if the
// designated constraints aren't met.
type QciValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QciValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QciValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QciValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QciValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QciValidationError) ErrorName() string { return "QciValidationError" }

// Error satisfies the builtin error interface
func (e QciValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQci.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QciValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QciValidationError{}

// Validate checks the field values on Arp with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Arp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Arp with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ArpMultiError, or nil if none found.
func (m *Arp) ValidateAll() error {
	return m.validate(true)
}

func (m *Arp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 15 {
		err := ArpValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 15]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ArpMultiError(errors)
	}

	return nil
}

// ArpMultiError is an error wrapping multiple validation errors returned by
// Arp.ValidateAll() if the designated constraints aren't met.
type ArpMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArpMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArpMultiError) AllErrors() []error { return m }

// ArpValidationError is the validation error returned by Arp.Validate if the
// designated constraints aren't met.
type ArpValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArpValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArpValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArpValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArpValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArpValidationError) ErrorName() string { return "ArpValidationError" }

// Error satisfies the builtin error interface
func (e ArpValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArpValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArpValidationError{}

// Validate checks the field values on GranularityPeriod with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GranularityPeriod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GranularityPeriod with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GranularityPeriodMultiError, or nil if none found.
func (m *GranularityPeriod) ValidateAll() error {
	return m.validate(true)
}

func (m *GranularityPeriod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := GranularityPeriodValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GranularityPeriodMultiError(errors)
	}

	return nil
}

// GranularityPeriodMultiError is an error wrapping multiple validation errors
// returned by GranularityPeriod.ValidateAll() if the designated constraints
// aren't met.
type GranularityPeriodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GranularityPeriodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GranularityPeriodMultiError) AllErrors() []error { return m }

// GranularityPeriodValidationError is the validation error returned by
// GranularityPeriod.Validate if the designated constraints aren't met.
type GranularityPeriodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GranularityPeriodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GranularityPeriodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GranularityPeriodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GranularityPeriodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GranularityPeriodValidationError) ErrorName() string {
	return "GranularityPeriodValidationError"
}

// Error satisfies the builtin error interface
func (e GranularityPeriodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGranularityPeriod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GranularityPeriodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GranularityPeriodValidationError{}

// Validate checks the field values on MeasurementType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeMultiError, or nil if none found.
func (m *MeasurementType) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.MeasurementType.(type) {

	case *MeasurementType_MeasName:

		if all {
			switch v := interface{}(m.GetMeasName()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasName",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasName",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasName()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementTypeValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MeasurementType_MeasId:

		if all {
			switch v := interface{}(m.GetMeasId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementTypeValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementTypeValidationError{
					field:  "MeasId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementTypeMultiError(errors)
	}

	return nil
}

// MeasurementTypeMultiError is an error wrapping multiple validation errors
// returned by MeasurementType.ValidateAll() if the designated constraints
// aren't met.
type MeasurementTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeMultiError) AllErrors() []error { return m }

// MeasurementTypeValidationError is the validation error returned by
// MeasurementType.Validate if the designated constraints aren't met.
type MeasurementTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeValidationError) ErrorName() string { return "MeasurementTypeValidationError" }

// Error satisfies the builtin error interface
func (e MeasurementTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeValidationError{}

// Validate checks the field values on MeasurementTypeId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeIdMultiError, or nil if none found.
func (m *MeasurementTypeId) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 65536 {
		err := MeasurementTypeIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeIdMultiError(errors)
	}

	return nil
}

// MeasurementTypeIdMultiError is an error wrapping multiple validation errors
// returned by MeasurementTypeId.ValidateAll() if the designated constraints
// aren't met.
type MeasurementTypeIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeIdMultiError) AllErrors() []error { return m }

// MeasurementTypeIdValidationError is the validation error returned by
// MeasurementTypeId.Validate if the designated constraints aren't met.
type MeasurementTypeIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeIdValidationError) ErrorName() string {
	return "MeasurementTypeIdValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeIdValidationError{}

// Validate checks the field values on SubscriptionId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubscriptionId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptionIdMultiError,
// or nil if none found.
func (m *SubscriptionId) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := SubscriptionIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SubscriptionIdMultiError(errors)
	}

	return nil
}

// SubscriptionIdMultiError is an error wrapping multiple validation errors
// returned by SubscriptionId.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionIdMultiError) AllErrors() []error { return m }

// SubscriptionIdValidationError is the validation error returned by
// SubscriptionId.Validate if the designated constraints aren't met.
type SubscriptionIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionIdValidationError) ErrorName() string { return "SubscriptionIdValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionIdValidationError{}

// Validate checks the field values on GlobalRmetnodeId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GlobalRmetnodeId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalRmetnodeId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalRmetnodeIdMultiError, or nil if none found.
func (m *GlobalRmetnodeId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalRmetnodeId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.GlobalRmetnodeId.(type) {

	case *GlobalRmetnodeId_GNb:

		if all {
			switch v := interface{}(m.GetGNb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "GNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "GNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeIdValidationError{
					field:  "GNb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GlobalRmetnodeId_EnGNb:

		if all {
			switch v := interface{}(m.GetEnGNb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "EnGNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "EnGNb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnGNb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeIdValidationError{
					field:  "EnGNb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GlobalRmetnodeId_NgENb:

		if all {
			switch v := interface{}(m.GetNgENb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "NgENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "NgENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNgENb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeIdValidationError{
					field:  "NgENb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GlobalRmetnodeId_ENb:

		if all {
			switch v := interface{}(m.GetENb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "ENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeIdValidationError{
						field:  "ENb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetENb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeIdValidationError{
					field:  "ENb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GlobalRmetnodeIdMultiError(errors)
	}

	return nil
}

// GlobalRmetnodeIdMultiError is an error wrapping multiple validation errors
// returned by GlobalRmetnodeId.ValidateAll() if the designated constraints
// aren't met.
type GlobalRmetnodeIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalRmetnodeIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalRmetnodeIdMultiError) AllErrors() []error { return m }

// GlobalRmetnodeIdValidationError is the validation error returned by
// GlobalRmetnodeId.Validate if the designated constraints aren't met.
type GlobalRmetnodeIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalRmetnodeIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalRmetnodeIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalRmetnodeIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalRmetnodeIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalRmetnodeIdValidationError) ErrorName() string { return "GlobalRmetnodeIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalRmetnodeIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalRmetnodeId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalRmetnodeIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalRmetnodeIdValidationError{}

// Validate checks the field values on GlobalRmetnodeGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalRmetnodeGnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalRmetnodeGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalRmetnodeGnbIdMultiError, or nil if none found.
func (m *GlobalRmetnodeGnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalRmetnodeGnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalGNbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalRmetnodeGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalRmetnodeGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalGNbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalRmetnodeGnbIdValidationError{
				field:  "GlobalGNbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GNbCuUpId != nil {

		if all {
			switch v := interface{}(m.GetGNbCuUpId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeGnbIdValidationError{
						field:  "GNbCuUpId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeGnbIdValidationError{
						field:  "GNbCuUpId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNbCuUpId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeGnbIdValidationError{
					field:  "GNbCuUpId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GNbDuId != nil {

		if all {
			switch v := interface{}(m.GetGNbDuId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeGnbIdValidationError{
						field:  "GNbDuId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeGnbIdValidationError{
						field:  "GNbDuId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNbDuId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeGnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GlobalRmetnodeGnbIdMultiError(errors)
	}

	return nil
}

// GlobalRmetnodeGnbIdMultiError is an error wrapping multiple validation
// errors returned by GlobalRmetnodeGnbId.ValidateAll() if the designated
// constraints aren't met.
type GlobalRmetnodeGnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalRmetnodeGnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalRmetnodeGnbIdMultiError) AllErrors() []error { return m }

// GlobalRmetnodeGnbIdValidationError is the validation error returned by
// GlobalRmetnodeGnbId.Validate if the designated constraints aren't met.
type GlobalRmetnodeGnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalRmetnodeGnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalRmetnodeGnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalRmetnodeGnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalRmetnodeGnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalRmetnodeGnbIdValidationError) ErrorName() string {
	return "GlobalRmetnodeGnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalRmetnodeGnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalRmetnodeGnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalRmetnodeGnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalRmetnodeGnbIdValidationError{}

// Validate checks the field values on GlobalgNbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalgNbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalgNbId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalgNbIdMultiError, or
// nil if none found.
func (m *GlobalgNbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalgNbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlmnId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlmnId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalgNbIdValidationError{
				field:  "PlmnId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGnbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "GnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalgNbIdValidationError{
					field:  "GnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGnbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalgNbIdValidationError{
				field:  "GnbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalgNbIdMultiError(errors)
	}

	return nil
}

// GlobalgNbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalgNbId.ValidateAll() if the designated constraints aren't met.
type GlobalgNbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalgNbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalgNbIdMultiError) AllErrors() []error { return m }

// GlobalgNbIdValidationError is the validation error returned by
// GlobalgNbId.Validate if the designated constraints aren't met.
type GlobalgNbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalgNbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalgNbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalgNbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalgNbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalgNbIdValidationError) ErrorName() string { return "GlobalgNbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalgNbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalgNbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalgNbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalgNbIdValidationError{}

// Validate checks the field values on GnbCuUpId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GnbCuUpId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GnbCuUpId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GnbCuUpIdMultiError, or nil
// if none found.
func (m *GnbCuUpId) ValidateAll() error {
	return m.validate(true)
}

func (m *GnbCuUpId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 68719476735 {
		err := GnbCuUpIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 68719476735]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GnbCuUpIdMultiError(errors)
	}

	return nil
}

// GnbCuUpIdMultiError is an error wrapping multiple validation errors returned
// by GnbCuUpId.ValidateAll() if the designated constraints aren't met.
type GnbCuUpIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GnbCuUpIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GnbCuUpIdMultiError) AllErrors() []error { return m }

// GnbCuUpIdValidationError is the validation error returned by
// GnbCuUpId.Validate if the designated constraints aren't met.
type GnbCuUpIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GnbCuUpIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GnbCuUpIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GnbCuUpIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GnbCuUpIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GnbCuUpIdValidationError) ErrorName() string { return "GnbCuUpIdValidationError" }

// Error satisfies the builtin error interface
func (e GnbCuUpIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGnbCuUpId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GnbCuUpIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GnbCuUpIdValidationError{}

// Validate checks the field values on GnbDuId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GnbDuId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GnbDuId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GnbDuIdMultiError, or nil if none found.
func (m *GnbDuId) ValidateAll() error {
	return m.validate(true)
}

func (m *GnbDuId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 68719476735 {
		err := GnbDuIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 68719476735]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GnbDuIdMultiError(errors)
	}

	return nil
}

// GnbDuIdMultiError is an error wrapping multiple validation errors returned
// by GnbDuId.ValidateAll() if the designated constraints aren't met.
type GnbDuIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GnbDuIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GnbDuIdMultiError) AllErrors() []error { return m }

// GnbDuIdValidationError is the validation error returned by GnbDuId.Validate
// if the designated constraints aren't met.
type GnbDuIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GnbDuIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GnbDuIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GnbDuIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GnbDuIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GnbDuIdValidationError) ErrorName() string { return "GnbDuIdValidationError" }

// Error satisfies the builtin error interface
func (e GnbDuIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGnbDuId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GnbDuIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GnbDuIdValidationError{}

// Validate checks the field values on GnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GnbIdChoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GnbIdChoiceMultiError, or
// nil if none found.
func (m *GnbIdChoice) ValidateAll() error {
	return m.validate(true)
}

func (m *GnbIdChoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.GnbIdChoice.(type) {

	case *GnbIdChoice_GnbId:

		if all {
			switch v := interface{}(m.GetGnbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GnbIdChoiceValidationError{
						field:  "GnbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GnbIdChoiceValidationError{
						field:  "GnbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGnbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GnbIdChoiceValidationError{
					field:  "GnbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GnbIdChoiceMultiError(errors)
	}

	return nil
}

// GnbIdChoiceMultiError is an error wrapping multiple validation errors
// returned by GnbIdChoice.ValidateAll() if the designated constraints aren't met.
type GnbIdChoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GnbIdChoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GnbIdChoiceMultiError) AllErrors() []error { return m }

// GnbIdChoiceValidationError is the validation error returned by
// GnbIdChoice.Validate if the designated constraints aren't met.
type GnbIdChoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GnbIdChoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GnbIdChoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GnbIdChoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GnbIdChoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GnbIdChoiceValidationError) ErrorName() string { return "GnbIdChoiceValidationError" }

// Error satisfies the builtin error interface
func (e GnbIdChoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGnbIdChoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GnbIdChoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GnbIdChoiceValidationError{}

// Validate checks the field values on GlobalRmetnodeEnGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalRmetnodeEnGnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalRmetnodeEnGnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalRmetnodeEnGnbIdMultiError, or nil if none found.
func (m *GlobalRmetnodeEnGnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalRmetnodeEnGnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalGNbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalRmetnodeEnGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalRmetnodeEnGnbIdValidationError{
					field:  "GlobalGNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalGNbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalRmetnodeEnGnbIdValidationError{
				field:  "GlobalGNbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GNbCuUpId != nil {

		if all {
			switch v := interface{}(m.GetGNbCuUpId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeEnGnbIdValidationError{
						field:  "GNbCuUpId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeEnGnbIdValidationError{
						field:  "GNbCuUpId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNbCuUpId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeEnGnbIdValidationError{
					field:  "GNbCuUpId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GNbDuId != nil {

		if all {
			switch v := interface{}(m.GetGNbDuId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeEnGnbIdValidationError{
						field:  "GNbDuId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeEnGnbIdValidationError{
						field:  "GNbDuId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNbDuId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeEnGnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GlobalRmetnodeEnGnbIdMultiError(errors)
	}

	return nil
}

// GlobalRmetnodeEnGnbIdMultiError is an error wrapping multiple validation
// errors returned by GlobalRmetnodeEnGnbId.ValidateAll() if the designated
// constraints aren't met.
type GlobalRmetnodeEnGnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalRmetnodeEnGnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalRmetnodeEnGnbIdMultiError) AllErrors() []error { return m }

// GlobalRmetnodeEnGnbIdValidationError is the validation error returned by
// GlobalRmetnodeEnGnbId.Validate if the designated constraints aren't met.
type GlobalRmetnodeEnGnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalRmetnodeEnGnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalRmetnodeEnGnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalRmetnodeEnGnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalRmetnodeEnGnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalRmetnodeEnGnbIdValidationError) ErrorName() string {
	return "GlobalRmetnodeEnGnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalRmetnodeEnGnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalRmetnodeEnGnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalRmetnodeEnGnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalRmetnodeEnGnbIdValidationError{}

// Validate checks the field values on GlobalenGnbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalenGnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalenGnbId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalenGnbIdMultiError, or
// nil if none found.
func (m *GlobalenGnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalenGnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalenGnbIdValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGNbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "GNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalenGnbIdValidationError{
					field:  "GNbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGNbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalenGnbIdValidationError{
				field:  "GNbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalenGnbIdMultiError(errors)
	}

	return nil
}

// GlobalenGnbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalenGnbId.ValidateAll() if the designated constraints
// aren't met.
type GlobalenGnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalenGnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalenGnbIdMultiError) AllErrors() []error { return m }

// GlobalenGnbIdValidationError is the validation error returned by
// GlobalenGnbId.Validate if the designated constraints aren't met.
type GlobalenGnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalenGnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalenGnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalenGnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalenGnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalenGnbIdValidationError) ErrorName() string { return "GlobalenGnbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalenGnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalenGnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalenGnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalenGnbIdValidationError{}

// Validate checks the field values on EngnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EngnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EngnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EngnbIdMultiError, or nil if none found.
func (m *EngnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *EngnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.EngnbId.(type) {

	case *EngnbId_GNbId:

		if all {
			switch v := interface{}(m.GetGNbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EngnbIdValidationError{
						field:  "GNbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EngnbIdValidationError{
						field:  "GNbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EngnbIdValidationError{
					field:  "GNbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EngnbIdMultiError(errors)
	}

	return nil
}

// EngnbIdMultiError is an error wrapping multiple validation errors returned
// by EngnbId.ValidateAll() if the designated constraints aren't met.
type EngnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EngnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EngnbIdMultiError) AllErrors() []error { return m }

// EngnbIdValidationError is the validation error returned by EngnbId.Validate
// if the designated constraints aren't met.
type EngnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EngnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EngnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EngnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EngnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EngnbIdValidationError) ErrorName() string { return "EngnbIdValidationError" }

// Error satisfies the builtin error interface
func (e EngnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEngnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EngnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EngnbIdValidationError{}

// Validate checks the field values on GlobalRmetnodeNgEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalRmetnodeNgEnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalRmetnodeNgEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalRmetnodeNgEnbIdMultiError, or nil if none found.
func (m *GlobalRmetnodeNgEnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalRmetnodeNgEnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalNgENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalRmetnodeNgEnbIdValidationError{
					field:  "GlobalNgENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalRmetnodeNgEnbIdValidationError{
					field:  "GlobalNgENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalNgENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalRmetnodeNgEnbIdValidationError{
				field:  "GlobalNgENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GNbDuId != nil {

		if all {
			switch v := interface{}(m.GetGNbDuId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GlobalRmetnodeNgEnbIdValidationError{
						field:  "GNbDuId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GlobalRmetnodeNgEnbIdValidationError{
						field:  "GNbDuId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGNbDuId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GlobalRmetnodeNgEnbIdValidationError{
					field:  "GNbDuId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GlobalRmetnodeNgEnbIdMultiError(errors)
	}

	return nil
}

// GlobalRmetnodeNgEnbIdMultiError is an error wrapping multiple validation
// errors returned by GlobalRmetnodeNgEnbId.ValidateAll() if the designated
// constraints aren't met.
type GlobalRmetnodeNgEnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalRmetnodeNgEnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalRmetnodeNgEnbIdMultiError) AllErrors() []error { return m }

// GlobalRmetnodeNgEnbIdValidationError is the validation error returned by
// GlobalRmetnodeNgEnbId.Validate if the designated constraints aren't met.
type GlobalRmetnodeNgEnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalRmetnodeNgEnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalRmetnodeNgEnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalRmetnodeNgEnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalRmetnodeNgEnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalRmetnodeNgEnbIdValidationError) ErrorName() string {
	return "GlobalRmetnodeNgEnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalRmetnodeNgEnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalRmetnodeNgEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalRmetnodeNgEnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalRmetnodeNgEnbIdValidationError{}

// Validate checks the field values on GlobalngeNbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalngeNbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalngeNbId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalngeNbIdMultiError, or
// nil if none found.
func (m *GlobalngeNbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalngeNbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlmnId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "PlmnId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlmnId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "PlmnId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "EnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "EnbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "EnbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetShortMacroENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "ShortMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "ShortMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShortMacroENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "ShortMacroENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLongMacroENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "LongMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalngeNbIdValidationError{
					field:  "LongMacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLongMacroENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalngeNbIdValidationError{
				field:  "LongMacroENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalngeNbIdMultiError(errors)
	}

	return nil
}

// GlobalngeNbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalngeNbId.ValidateAll() if the designated constraints
// aren't met.
type GlobalngeNbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalngeNbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalngeNbIdMultiError) AllErrors() []error { return m }

// GlobalngeNbIdValidationError is the validation error returned by
// GlobalngeNbId.Validate if the designated constraints aren't met.
type GlobalngeNbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalngeNbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalngeNbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalngeNbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalngeNbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalngeNbIdValidationError) ErrorName() string { return "GlobalngeNbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalngeNbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalngeNbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalngeNbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalngeNbIdValidationError{}

// Validate checks the field values on EnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnbIdChoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnbIdChoice with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnbIdChoiceMultiError, or
// nil if none found.
func (m *EnbIdChoice) ValidateAll() error {
	return m.validate(true)
}

func (m *EnbIdChoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.EnbIdChoice.(type) {

	case *EnbIdChoice_EnbIdMacro:

		if all {
			switch v := interface{}(m.GetEnbIdMacro()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdMacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdMacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnbIdMacro()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdChoiceValidationError{
					field:  "EnbIdMacro",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnbIdChoice_EnbIdShortmacro:

		if all {
			switch v := interface{}(m.GetEnbIdShortmacro()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdShortmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdShortmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnbIdShortmacro()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdChoiceValidationError{
					field:  "EnbIdShortmacro",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnbIdChoice_EnbIdLongmacro:

		if all {
			switch v := interface{}(m.GetEnbIdLongmacro()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdLongmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdChoiceValidationError{
						field:  "EnbIdLongmacro",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnbIdLongmacro()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdChoiceValidationError{
					field:  "EnbIdLongmacro",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnbIdChoiceMultiError(errors)
	}

	return nil
}

// EnbIdChoiceMultiError is an error wrapping multiple validation errors
// returned by EnbIdChoice.ValidateAll() if the designated constraints aren't met.
type EnbIdChoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnbIdChoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnbIdChoiceMultiError) AllErrors() []error { return m }

// EnbIdChoiceValidationError is the validation error returned by
// EnbIdChoice.Validate if the designated constraints aren't met.
type EnbIdChoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnbIdChoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnbIdChoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnbIdChoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnbIdChoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnbIdChoiceValidationError) ErrorName() string { return "EnbIdChoiceValidationError" }

// Error satisfies the builtin error interface
func (e EnbIdChoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnbIdChoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnbIdChoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnbIdChoiceValidationError{}

// Validate checks the field values on GlobalRmetnodeEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GlobalRmetnodeEnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalRmetnodeEnbId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalRmetnodeEnbIdMultiError, or nil if none found.
func (m *GlobalRmetnodeEnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalRmetnodeEnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGlobalENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalRmetnodeEnbIdValidationError{
					field:  "GlobalENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalRmetnodeEnbIdValidationError{
					field:  "GlobalENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGlobalENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalRmetnodeEnbIdValidationError{
				field:  "GlobalENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalRmetnodeEnbIdMultiError(errors)
	}

	return nil
}

// GlobalRmetnodeEnbIdMultiError is an error wrapping multiple validation
// errors returned by GlobalRmetnodeEnbId.ValidateAll() if the designated
// constraints aren't met.
type GlobalRmetnodeEnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalRmetnodeEnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalRmetnodeEnbIdMultiError) AllErrors() []error { return m }

// GlobalRmetnodeEnbIdValidationError is the validation error returned by
// GlobalRmetnodeEnbId.Validate if the designated constraints aren't met.
type GlobalRmetnodeEnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalRmetnodeEnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalRmetnodeEnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalRmetnodeEnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalRmetnodeEnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalRmetnodeEnbIdValidationError) ErrorName() string {
	return "GlobalRmetnodeEnbIdValidationError"
}

// Error satisfies the builtin error interface
func (e GlobalRmetnodeEnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalRmetnodeEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalRmetnodeEnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalRmetnodeEnbIdValidationError{}

// Validate checks the field values on GlobalEnbId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GlobalEnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalEnbId with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GlobalEnbIdMultiError, or
// nil if none found.
func (m *GlobalEnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalEnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPLmnIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "PLmnIdentity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPLmnIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalEnbIdValidationError{
				field:  "PLmnIdentity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetENbId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "ENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobalEnbIdValidationError{
					field:  "ENbId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetENbId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobalEnbIdValidationError{
				field:  "ENbId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobalEnbIdMultiError(errors)
	}

	return nil
}

// GlobalEnbIdMultiError is an error wrapping multiple validation errors
// returned by GlobalEnbId.ValidateAll() if the designated constraints aren't met.
type GlobalEnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalEnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalEnbIdMultiError) AllErrors() []error { return m }

// GlobalEnbIdValidationError is the validation error returned by
// GlobalEnbId.Validate if the designated constraints aren't met.
type GlobalEnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalEnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalEnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalEnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalEnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalEnbIdValidationError) ErrorName() string { return "GlobalEnbIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalEnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalEnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalEnbIdValidationError{}

// Validate checks the field values on EnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnbId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnbId with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EnbIdMultiError, or nil if none found.
func (m *EnbId) ValidateAll() error {
	return m.validate(true)
}

func (m *EnbId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.EnbId.(type) {

	case *EnbId_MacroENbId:

		if all {
			switch v := interface{}(m.GetMacroENbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "MacroENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "MacroENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMacroENbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdValidationError{
					field:  "MacroENbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnbId_HomeENbId:

		if all {
			switch v := interface{}(m.GetHomeENbId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "HomeENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnbIdValidationError{
						field:  "HomeENbId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHomeENbId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnbIdValidationError{
					field:  "HomeENbId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnbIdMultiError(errors)
	}

	return nil
}

// EnbIdMultiError is an error wrapping multiple validation errors returned by
// EnbId.ValidateAll() if the designated constraints aren't met.
type EnbIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnbIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnbIdMultiError) AllErrors() []error { return m }

// EnbIdValidationError is the validation error returned by EnbId.Validate if
// the designated constraints aren't met.
type EnbIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnbIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnbIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnbIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnbIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnbIdValidationError) ErrorName() string { return "EnbIdValidationError" }

// Error satisfies the builtin error interface
func (e EnbIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnbId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnbIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnbIdValidationError{}

// Validate checks the field values on RanfunctionName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RanfunctionName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RanfunctionName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RanfunctionNameMultiError, or nil if none found.
func (m *RanfunctionName) ValidateAll() error {
	return m.validate(true)
}

func (m *RanfunctionName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetRanFunctionShortName()); l < 1 || l > 150 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionShortName",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRanFunctionE2SmOid()); l < 1 || l > 1000 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionE2SmOid",
			reason: "value length must be between 1 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRanFunctionDescription()); l < 1 || l > 150 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionDescription",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RanFunctionInstance != nil {
		// no validation rules for RanFunctionInstance
	}

	if len(errors) > 0 {
		return RanfunctionNameMultiError(errors)
	}

	return nil
}

// RanfunctionNameMultiError is an error wrapping multiple validation errors
// returned by RanfunctionName.ValidateAll() if the designated constraints
// aren't met.
type RanfunctionNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RanfunctionNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RanfunctionNameMultiError) AllErrors() []error { return m }

// RanfunctionNameValidationError is the validation error returned by
// RanfunctionName.Validate if the designated constraints aren't met.
type RanfunctionNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RanfunctionNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RanfunctionNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RanfunctionNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RanfunctionNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RanfunctionNameValidationError) ErrorName() string { return "RanfunctionNameValidationError" }

// Error satisfies the builtin error interface
func (e RanfunctionNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRanfunctionName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RanfunctionNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RanfunctionNameValidationError{}

// Validate checks the field values on RicStyleType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleTypeMultiError, or
// nil if none found.
func (m *RicStyleType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := RicStyleTypeValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicStyleTypeMultiError(errors)
	}

	return nil
}

// RicStyleTypeMultiError is an error wrapping multiple validation errors
// returned by RicStyleType.ValidateAll() if the designated constraints aren't met.
type RicStyleTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleTypeMultiError) AllErrors() []error { return m }

// RicStyleTypeValidationError is the validation error returned by
// RicStyleType.Validate if the designated constraints aren't met.
type RicStyleTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleTypeValidationError) ErrorName() string { return "RicStyleTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleTypeValidationError{}

// Validate checks the field values on RicFormatType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicFormatType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicFormatType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicFormatTypeMultiError, or
// nil if none found.
func (m *RicFormatType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicFormatType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := RicFormatTypeValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicFormatTypeMultiError(errors)
	}

	return nil
}

// RicFormatTypeMultiError is an error wrapping multiple validation errors
// returned by RicFormatType.ValidateAll() if the designated constraints
// aren't met.
type RicFormatTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicFormatTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicFormatTypeMultiError) AllErrors() []error { return m }

// RicFormatTypeValidationError is the validation error returned by
// RicFormatType.Validate if the designated constraints aren't met.
type RicFormatTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicFormatTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicFormatTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicFormatTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicFormatTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicFormatTypeValidationError) ErrorName() string { return "RicFormatTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicFormatTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicFormatType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicFormatTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicFormatTypeValidationError{}

// Validate checks the field values on MaxnoofRmetnodes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofRmetnodes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofRmetnodes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofRmetnodesMultiError, or nil if none found.
func (m *MaxnoofRmetnodes) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofRmetnodes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 1024 {
		err := MaxnoofRmetnodesValidationError{
			field:  "Value",
			reason: "value must equal 1024",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofRmetnodesMultiError(errors)
	}

	return nil
}

// MaxnoofRmetnodesMultiError is an error wrapping multiple validation errors
// returned by MaxnoofRmetnodes.ValidateAll() if the designated constraints
// aren't met.
type MaxnoofRmetnodesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofRmetnodesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofRmetnodesMultiError) AllErrors() []error { return m }

// MaxnoofRmetnodesValidationError is the validation error returned by
// MaxnoofRmetnodes.Validate if the designated constraints aren't met.
type MaxnoofRmetnodesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofRmetnodesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofRmetnodesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofRmetnodesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofRmetnodesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofRmetnodesValidationError) ErrorName() string { return "MaxnoofRmetnodesValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofRmetnodesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofRmetnodes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofRmetnodesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofRmetnodesValidationError{}

// Validate checks the field values on MaxnoofCells with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxnoofCells) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofCells with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MaxnoofCellsMultiError, or
// nil if none found.
func (m *MaxnoofCells) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofCells) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 16384 {
		err := MaxnoofCellsValidationError{
			field:  "Value",
			reason: "value must equal 16384",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofCellsMultiError(errors)
	}

	return nil
}

// MaxnoofCellsMultiError is an error wrapping multiple validation errors
// returned by MaxnoofCells.ValidateAll() if the designated constraints aren't met.
type MaxnoofCellsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofCellsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofCellsMultiError) AllErrors() []error { return m }

// MaxnoofCellsValidationError is the validation error returned by
// MaxnoofCells.Validate if the designated constraints aren't met.
type MaxnoofCellsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofCellsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofCellsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofCellsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofCellsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofCellsValidationError) ErrorName() string { return "MaxnoofCellsValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofCellsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofCells.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofCellsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofCellsValidationError{}

// Validate checks the field values on MaxnoofRicstyles with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofRicstyles) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofRicstyles with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofRicstylesMultiError, or nil if none found.
func (m *MaxnoofRicstyles) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofRicstyles) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 63 {
		err := MaxnoofRicstylesValidationError{
			field:  "Value",
			reason: "value must equal 63",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofRicstylesMultiError(errors)
	}

	return nil
}

// MaxnoofRicstylesMultiError is an error wrapping multiple validation errors
// returned by MaxnoofRicstyles.ValidateAll() if the designated constraints
// aren't met.
type MaxnoofRicstylesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofRicstylesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofRicstylesMultiError) AllErrors() []error { return m }

// MaxnoofRicstylesValidationError is the validation error returned by
// MaxnoofRicstyles.Validate if the designated constraints aren't met.
type MaxnoofRicstylesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofRicstylesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofRicstylesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofRicstylesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofRicstylesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofRicstylesValidationError) ErrorName() string { return "MaxnoofRicstylesValidationError" }

// Error satisfies the builtin error interface
func (e MaxnoofRicstylesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofRicstyles.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofRicstylesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofRicstylesValidationError{}

// Validate checks the field values on MaxnoofMeasurementInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofMeasurementInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofMeasurementInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofMeasurementInfoMultiError, or nil if none found.
func (m *MaxnoofMeasurementInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofMeasurementInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65536 {
		err := MaxnoofMeasurementInfoValidationError{
			field:  "Value",
			reason: "value must equal 65536",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofMeasurementInfoMultiError(errors)
	}

	return nil
}

// MaxnoofMeasurementInfoMultiError is an error wrapping multiple validation
// errors returned by MaxnoofMeasurementInfo.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofMeasurementInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofMeasurementInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofMeasurementInfoMultiError) AllErrors() []error { return m }

// MaxnoofMeasurementInfoValidationError is the validation error returned by
// MaxnoofMeasurementInfo.Validate if the designated constraints aren't met.
type MaxnoofMeasurementInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofMeasurementInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofMeasurementInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofMeasurementInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofMeasurementInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofMeasurementInfoValidationError) ErrorName() string {
	return "MaxnoofMeasurementInfoValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofMeasurementInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofMeasurementInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofMeasurementInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofMeasurementInfoValidationError{}

// Validate checks the field values on MaxnoofMeasurementRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofMeasurementRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofMeasurementRecord with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofMeasurementRecordMultiError, or nil if none found.
func (m *MaxnoofMeasurementRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofMeasurementRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65536 {
		err := MaxnoofMeasurementRecordValidationError{
			field:  "Value",
			reason: "value must equal 65536",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofMeasurementRecordMultiError(errors)
	}

	return nil
}

// MaxnoofMeasurementRecordMultiError is an error wrapping multiple validation
// errors returned by MaxnoofMeasurementRecord.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofMeasurementRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofMeasurementRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofMeasurementRecordMultiError) AllErrors() []error { return m }

// MaxnoofMeasurementRecordValidationError is the validation error returned by
// MaxnoofMeasurementRecord.Validate if the designated constraints aren't met.
type MaxnoofMeasurementRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofMeasurementRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofMeasurementRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofMeasurementRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofMeasurementRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofMeasurementRecordValidationError) ErrorName() string {
	return "MaxnoofMeasurementRecordValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofMeasurementRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofMeasurementRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofMeasurementRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofMeasurementRecordValidationError{}

// Validate checks the field values on MaxnoofMeasurementValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MaxnoofMeasurementValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxnoofMeasurementValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MaxnoofMeasurementValueMultiError, or nil if none found.
func (m *MaxnoofMeasurementValue) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxnoofMeasurementValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65536 {
		err := MaxnoofMeasurementValueValidationError{
			field:  "Value",
			reason: "value must equal 65536",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxnoofMeasurementValueMultiError(errors)
	}

	return nil
}

// MaxnoofMeasurementValueMultiError is an error wrapping multiple validation
// errors returned by MaxnoofMeasurementValue.ValidateAll() if the designated
// constraints aren't met.
type MaxnoofMeasurementValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxnoofMeasurementValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxnoofMeasurementValueMultiError) AllErrors() []error { return m }

// MaxnoofMeasurementValueValidationError is the validation error returned by
// MaxnoofMeasurementValue.Validate if the designated constraints aren't met.
type MaxnoofMeasurementValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxnoofMeasurementValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxnoofMeasurementValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxnoofMeasurementValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxnoofMeasurementValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxnoofMeasurementValueValidationError) ErrorName() string {
	return "MaxnoofMeasurementValueValidationError"
}

// Error satisfies the builtin error interface
func (e MaxnoofMeasurementValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxnoofMeasurementValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxnoofMeasurementValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxnoofMeasurementValueValidationError{}

// Validate checks the field values on MaxofUe with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxofUe) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxofUe with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MaxofUeMultiError, or nil if none found.
func (m *MaxofUe) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxofUe) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65536 {
		err := MaxofUeValidationError{
			field:  "Value",
			reason: "value must equal 65536",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxofUeMultiError(errors)
	}

	return nil
}

// MaxofUeMultiError is an error wrapping multiple validation errors returned
// by MaxofUe.ValidateAll() if the designated constraints aren't met.
type MaxofUeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxofUeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxofUeMultiError) AllErrors() []error { return m }

// MaxofUeValidationError is the validation error returned by MaxofUe.Validate
// if the designated constraints aren't met.
type MaxofUeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxofUeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxofUeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxofUeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxofUeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxofUeValidationError) ErrorName() string { return "MaxofUeValidationError" }

// Error satisfies the builtin error interface
func (e MaxofUeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxofUe.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxofUeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxofUeValidationError{}

// Validate checks the field values on Ueid with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Ueid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ueid with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UeidMultiError, or nil if none found.
func (m *Ueid) ValidateAll() error {
	return m.validate(true)
}

func (m *Ueid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := UeidValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UeidMultiError(errors)
	}

	return nil
}

// UeidMultiError is an error wrapping multiple validation errors returned by
// Ueid.ValidateAll() if the designated constraints aren't met.
type UeidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeidMultiError) AllErrors() []error { return m }

// UeidValidationError is the validation error returned by Ueid.Validate if the
// designated constraints aren't met.
type UeidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeidValidationError) ErrorName() string { return "UeidValidationError" }

// Error satisfies the builtin error interface
func (e UeidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeidValidationError{}

// Validate checks the field values on Ueitem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Ueitem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ueitem with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UeitemMultiError, or nil if none found.
func (m *Ueitem) ValidateAll() error {
	return m.validate(true)
}

func (m *Ueitem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UeitemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UeitemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UeitemValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.UeTag != nil {

		if all {
			switch v := interface{}(m.GetUeTag()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeitemValidationError{
						field:  "UeTag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeitemValidationError{
						field:  "UeTag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUeTag()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeitemValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UeitemMultiError(errors)
	}

	return nil
}

// UeitemMultiError is an error wrapping multiple validation errors returned by
// Ueitem.ValidateAll() if the designated constraints aren't met.
type UeitemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeitemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeitemMultiError) AllErrors() []error { return m }

// UeitemValidationError is the validation error returned by Ueitem.Validate if
// the designated constraints aren't met.
type UeitemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeitemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeitemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeitemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeitemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeitemValidationError) ErrorName() string { return "UeitemValidationError" }

// Error satisfies the builtin error interface
func (e UeitemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeitem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeitemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeitemValidationError{}

// Validate checks the field values on Uelist with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Uelist) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uelist with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UelistMultiError, or nil if none found.
func (m *Uelist) ValidateAll() error {
	return m.validate(true)
}

func (m *Uelist) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UelistValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UelistValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UelistValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UelistMultiError(errors)
	}

	return nil
}

// UelistMultiError is an error wrapping multiple validation errors returned by
// Uelist.ValidateAll() if the designated constraints aren't met.
type UelistMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UelistMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UelistMultiError) AllErrors() []error { return m }

// UelistValidationError is the validation error returned by Uelist.Validate if
// the designated constraints aren't met.
type UelistValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UelistValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UelistValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UelistValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UelistValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UelistValidationError) ErrorName() string { return "UelistValidationError" }

// Error satisfies the builtin error interface
func (e UelistValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUelist.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UelistValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UelistValidationError{}

// Validate checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoListMultiError, or nil if none found.
func (m *MeasurementInfoList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoListMultiError(errors)
	}

	return nil
}

// MeasurementInfoListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoList.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoListMultiError) AllErrors() []error { return m }

// MeasurementInfoListValidationError is the validation error returned by
// MeasurementInfoList.Validate if the designated constraints aren't met.
type MeasurementInfoListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoListValidationError) ErrorName() string {
	return "MeasurementInfoListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoListValidationError{}

// Validate checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoItemMultiError, or nil if none found.
func (m *MeasurementInfoItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoItemValidationError{
					field:  "MeasType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoItemValidationError{
				field:  "MeasType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MeasurementInfoItemMultiError(errors)
	}

	return nil
}

// MeasurementInfoItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoItemMultiError) AllErrors() []error { return m }

// MeasurementInfoItemValidationError is the validation error returned by
// MeasurementInfoItem.Validate if the designated constraints aren't met.
type MeasurementInfoItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoItemValidationError) ErrorName() string {
	return "MeasurementInfoItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoItemValidationError{}

// Validate checks the field values on MeasurementData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementDataMultiError, or nil if none found.
func (m *MeasurementData) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementDataValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementDataMultiError(errors)
	}

	return nil
}

// MeasurementDataMultiError is an error wrapping multiple validation errors
// returned by MeasurementData.ValidateAll() if the designated constraints
// aren't met.
type MeasurementDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementDataMultiError) AllErrors() []error { return m }

// MeasurementDataValidationError is the validation error returned by
// MeasurementData.Validate if the designated constraints aren't met.
type MeasurementDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementDataValidationError) ErrorName() string { return "MeasurementDataValidationError" }

// Error satisfies the builtin error interface
func (e MeasurementDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementDataValidationError{}

// Validate checks the field values on MeasurementRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordMultiError, or nil if none found.
func (m *MeasurementRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementRecordValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUeTag()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeTag()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementRecordValidationError{
				field:  "UeTag",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMeasRecordItem() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementRecordValidationError{
						field:  fmt.Sprintf("MeasRecordItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementRecordValidationError{
						field:  fmt.Sprintf("MeasRecordItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementRecordValidationError{
					field:  fmt.Sprintf("MeasRecordItem[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementRecordMultiError(errors)
	}

	return nil
}

// MeasurementRecordMultiError is an error wrapping multiple validation errors
// returned by MeasurementRecord.ValidateAll() if the designated constraints
// aren't met.
type MeasurementRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordMultiError) AllErrors() []error { return m }

// MeasurementRecordValidationError is the validation error returned by
// MeasurementRecord.Validate if the designated constraints aren't met.
type MeasurementRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordValidationError) ErrorName() string {
	return "MeasurementRecordValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordValidationError{}

// Validate checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecordItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordItemMultiError, or nil if none found.
func (m *MeasurementRecordItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecordItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.MeasurementRecordItem.(type) {

	case *MeasurementRecordItem_Integer:
		// no validation rules for Integer

	case *MeasurementRecordItem_Real:
		// no validation rules for Real

	case *MeasurementRecordItem_NoValue:
		// no validation rules for NoValue

	}

	if len(errors) > 0 {
		return MeasurementRecordItemMultiError(errors)
	}

	return nil
}

// MeasurementRecordItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementRecordItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementRecordItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordItemMultiError) AllErrors() []error { return m }

// MeasurementRecordItemValidationError is the validation error returned by
// MeasurementRecordItem.Validate if the designated constraints aren't met.
type MeasurementRecordItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordItemValidationError) ErrorName() string {
	return "MeasurementRecordItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecordItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordItemValidationError{}

// Validate checks the field values on MeasurementInfoActionList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionListMultiError, or nil if none found.
func (m *MeasurementInfoActionList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoActionListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoActionListMultiError(errors)
	}

	return nil
}

// MeasurementInfoActionListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionList.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionListMultiError) AllErrors() []error { return m }

// MeasurementInfoActionListValidationError is the validation error returned by
// MeasurementInfoActionList.Validate if the designated constraints aren't met.
type MeasurementInfoActionListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionListValidationError) ErrorName() string {
	return "MeasurementInfoActionListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionListValidationError{}

// Validate checks the field values on MeasurementInfoActionItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionItemMultiError, or nil if none found.
func (m *MeasurementInfoActionItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoActionItemValidationError{
				field:  "MeasName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.MeasId != nil {

		if all {
			switch v := interface{}(m.GetMeasId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoActionItemValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoActionItemValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoActionItemValidationError{
					field:  "MeasId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoActionItemMultiError(errors)
	}

	return nil
}

// MeasurementInfoActionItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionItem.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionItemMultiError) AllErrors() []error { return m }

// MeasurementInfoActionItemValidationError is the validation error returned by
// MeasurementInfoActionItem.Validate if the designated constraints aren't met.
type MeasurementInfoActionItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionItemValidationError) ErrorName() string {
	return "MeasurementInfoActionItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionItemValidationError{}

// Validate checks the field values on E2SmRmetEventTriggerDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRmetEventTriggerDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetEventTriggerDefinition with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRmetEventTriggerDefinitionMultiError, or nil if none found.
func (m *E2SmRmetEventTriggerDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetEventTriggerDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDefinitionFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDefinitionFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetEventTriggerDefinitionValidationError{
				field:  "EventDefinitionFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmRmetEventTriggerDefinitionMultiError(errors)
	}

	return nil
}

// E2SmRmetEventTriggerDefinitionMultiError is an error wrapping multiple
// validation errors returned by E2SmRmetEventTriggerDefinition.ValidateAll()
// if the designated constraints aren't met.
type E2SmRmetEventTriggerDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetEventTriggerDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetEventTriggerDefinitionMultiError) AllErrors() []error { return m }

// E2SmRmetEventTriggerDefinitionValidationError is the validation error
// returned by E2SmRmetEventTriggerDefinition.Validate if the designated
// constraints aren't met.
type E2SmRmetEventTriggerDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetEventTriggerDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetEventTriggerDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetEventTriggerDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetEventTriggerDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetEventTriggerDefinitionValidationError) ErrorName() string {
	return "E2SmRmetEventTriggerDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetEventTriggerDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetEventTriggerDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetEventTriggerDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetEventTriggerDefinitionValidationError{}

// Validate checks the field values on EventTriggerDefinitionFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventTriggerDefinitionFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventTriggerDefinitionFormats with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EventTriggerDefinitionFormatsMultiError, or nil if none found.
func (m *EventTriggerDefinitionFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *EventTriggerDefinitionFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRmetEventTriggerDefinition.(type) {

	case *EventTriggerDefinitionFormats_EventDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetEventDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventTriggerDefinitionFormatsValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventTriggerDefinitionFormatsValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEventDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventTriggerDefinitionFormatsValidationError{
					field:  "EventDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EventTriggerDefinitionFormatsMultiError(errors)
	}

	return nil
}

// EventTriggerDefinitionFormatsMultiError is an error wrapping multiple
// validation errors returned by EventTriggerDefinitionFormats.ValidateAll()
// if the designated constraints aren't met.
type EventTriggerDefinitionFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventTriggerDefinitionFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventTriggerDefinitionFormatsMultiError) AllErrors() []error { return m }

// EventTriggerDefinitionFormatsValidationError is the validation error
// returned by EventTriggerDefinitionFormats.Validate if the designated
// constraints aren't met.
type EventTriggerDefinitionFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventTriggerDefinitionFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventTriggerDefinitionFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventTriggerDefinitionFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventTriggerDefinitionFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventTriggerDefinitionFormatsValidationError) ErrorName() string {
	return "EventTriggerDefinitionFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e EventTriggerDefinitionFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventTriggerDefinitionFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventTriggerDefinitionFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventTriggerDefinitionFormatsValidationError{}

// Validate checks the field values on E2SmRmetEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *E2SmRmetEventTriggerDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// E2SmRmetEventTriggerDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmRmetEventTriggerDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetEventTriggerDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReportingPeriod

	if len(errors) > 0 {
		return E2SmRmetEventTriggerDefinitionFormat1MultiError(errors)
	}

	return nil
}

// E2SmRmetEventTriggerDefinitionFormat1MultiError is an error wrapping
// multiple validation errors returned by
// E2SmRmetEventTriggerDefinitionFormat1.ValidateAll() if the designated
// constraints aren't met.
type E2SmRmetEventTriggerDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetEventTriggerDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetEventTriggerDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmRmetEventTriggerDefinitionFormat1ValidationError is the validation error
// returned by E2SmRmetEventTriggerDefinitionFormat1.Validate if the
// designated constraints aren't met.
type E2SmRmetEventTriggerDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetEventTriggerDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetEventTriggerDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetEventTriggerDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetEventTriggerDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetEventTriggerDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmRmetEventTriggerDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetEventTriggerDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetEventTriggerDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetEventTriggerDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetEventTriggerDefinitionFormat1ValidationError{}

// Validate checks the field values on E2SmRmetActionDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRmetActionDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetActionDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmRmetActionDefinitionMultiError, or nil if none found.
func (m *E2SmRmetActionDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetActionDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetActionDefinitionValidationError{
				field:  "RicStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActionDefinitionFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionValidationError{
					field:  "ActionDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionValidationError{
					field:  "ActionDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionDefinitionFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetActionDefinitionValidationError{
				field:  "ActionDefinitionFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmRmetActionDefinitionMultiError(errors)
	}

	return nil
}

// E2SmRmetActionDefinitionMultiError is an error wrapping multiple validation
// errors returned by E2SmRmetActionDefinition.ValidateAll() if the designated
// constraints aren't met.
type E2SmRmetActionDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetActionDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetActionDefinitionMultiError) AllErrors() []error { return m }

// E2SmRmetActionDefinitionValidationError is the validation error returned by
// E2SmRmetActionDefinition.Validate if the designated constraints aren't met.
type E2SmRmetActionDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetActionDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetActionDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetActionDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetActionDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetActionDefinitionValidationError) ErrorName() string {
	return "E2SmRmetActionDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetActionDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetActionDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetActionDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetActionDefinitionValidationError{}

// Validate checks the field values on ActionDefinitionFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActionDefinitionFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionDefinitionFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActionDefinitionFormatsMultiError, or nil if none found.
func (m *ActionDefinitionFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionDefinitionFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRmetActionDefinition.(type) {

	case *ActionDefinitionFormats_ActionDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetActionDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDefinitionFormatsValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDefinitionFormatsValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDefinitionFormatsValidationError{
					field:  "ActionDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionDefinitionFormatsMultiError(errors)
	}

	return nil
}

// ActionDefinitionFormatsMultiError is an error wrapping multiple validation
// errors returned by ActionDefinitionFormats.ValidateAll() if the designated
// constraints aren't met.
type ActionDefinitionFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionDefinitionFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionDefinitionFormatsMultiError) AllErrors() []error { return m }

// ActionDefinitionFormatsValidationError is the validation error returned by
// ActionDefinitionFormats.Validate if the designated constraints aren't met.
type ActionDefinitionFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionDefinitionFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionDefinitionFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionDefinitionFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionDefinitionFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionDefinitionFormatsValidationError) ErrorName() string {
	return "ActionDefinitionFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e ActionDefinitionFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionDefinitionFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionDefinitionFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionDefinitionFormatsValidationError{}

// Validate checks the field values on E2SmRmetActionDefinitionFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRmetActionDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetActionDefinitionFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRmetActionDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmRmetActionDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetActionDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCellObjId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetActionDefinitionFormat1ValidationError{
				field:  "CellObjId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetActionDefinitionFormat1ValidationError{
				field:  "MeasInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGranulPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetActionDefinitionFormat1ValidationError{
				field:  "GranulPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetActionDefinitionFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmRmetActionDefinitionFormat1MultiError(errors)
	}

	return nil
}

// E2SmRmetActionDefinitionFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmRmetActionDefinitionFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmRmetActionDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetActionDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetActionDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmRmetActionDefinitionFormat1ValidationError is the validation error
// returned by E2SmRmetActionDefinitionFormat1.Validate if the designated
// constraints aren't met.
type E2SmRmetActionDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetActionDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetActionDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetActionDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetActionDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetActionDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmRmetActionDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetActionDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetActionDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetActionDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetActionDefinitionFormat1ValidationError{}

// Validate checks the field values on E2SmRmetIndicationHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRmetIndicationHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetIndicationHeader with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmRmetIndicationHeaderMultiError, or nil if none found.
func (m *E2SmRmetIndicationHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetIndicationHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIndicationHeaderFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetIndicationHeaderValidationError{
					field:  "IndicationHeaderFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetIndicationHeaderValidationError{
					field:  "IndicationHeaderFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndicationHeaderFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetIndicationHeaderValidationError{
				field:  "IndicationHeaderFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmRmetIndicationHeaderMultiError(errors)
	}

	return nil
}

// E2SmRmetIndicationHeaderMultiError is an error wrapping multiple validation
// errors returned by E2SmRmetIndicationHeader.ValidateAll() if the designated
// constraints aren't met.
type E2SmRmetIndicationHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetIndicationHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetIndicationHeaderMultiError) AllErrors() []error { return m }

// E2SmRmetIndicationHeaderValidationError is the validation error returned by
// E2SmRmetIndicationHeader.Validate if the designated constraints aren't met.
type E2SmRmetIndicationHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetIndicationHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetIndicationHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetIndicationHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetIndicationHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetIndicationHeaderValidationError) ErrorName() string {
	return "E2SmRmetIndicationHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetIndicationHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetIndicationHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetIndicationHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetIndicationHeaderValidationError{}

// Validate checks the field values on IndicationHeaderFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndicationHeaderFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndicationHeaderFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndicationHeaderFormatsMultiError, or nil if none found.
func (m *IndicationHeaderFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicationHeaderFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRmetIndicationHeader.(type) {

	case *IndicationHeaderFormats_IndicationHeaderFormat1:

		if all {
			switch v := interface{}(m.GetIndicationHeaderFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndicationHeaderFormatsValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndicationHeaderFormatsValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationHeaderFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndicationHeaderFormatsValidationError{
					field:  "IndicationHeaderFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndicationHeaderFormatsMultiError(errors)
	}

	return nil
}

// IndicationHeaderFormatsMultiError is an error wrapping multiple validation
// errors returned by IndicationHeaderFormats.ValidateAll() if the designated
// constraints aren't met.
type IndicationHeaderFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicationHeaderFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicationHeaderFormatsMultiError) AllErrors() []error { return m }

// IndicationHeaderFormatsValidationError is the validation error returned by
// IndicationHeaderFormats.Validate if the designated constraints aren't met.
type IndicationHeaderFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicationHeaderFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndicationHeaderFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndicationHeaderFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicationHeaderFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicationHeaderFormatsValidationError) ErrorName() string {
	return "IndicationHeaderFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e IndicationHeaderFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicationHeaderFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicationHeaderFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicationHeaderFormatsValidationError{}

// Validate checks the field values on E2SmRmetIndicationHeaderFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRmetIndicationHeaderFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetIndicationHeaderFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRmetIndicationHeaderFormat1MultiError, or nil if none found.
func (m *E2SmRmetIndicationHeaderFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetIndicationHeaderFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetColletStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetColletStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetIndicationHeaderFormat1ValidationError{
				field:  "ColletStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.FileFormatversion != nil {

		if l := utf8.RuneCountInString(m.GetFileFormatversion()); l < 0 || l > 15 {
			err := E2SmRmetIndicationHeaderFormat1ValidationError{
				field:  "FileFormatversion",
				reason: "value length must be between 0 and 15 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.SenderName != nil {

		if l := utf8.RuneCountInString(m.GetSenderName()); l < 0 || l > 400 {
			err := E2SmRmetIndicationHeaderFormat1ValidationError{
				field:  "SenderName",
				reason: "value length must be between 0 and 400 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.SenderType != nil {

		if l := utf8.RuneCountInString(m.GetSenderType()); l < 0 || l > 8 {
			err := E2SmRmetIndicationHeaderFormat1ValidationError{
				field:  "SenderType",
				reason: "value length must be between 0 and 8 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.VendorName != nil {

		if l := utf8.RuneCountInString(m.GetVendorName()); l < 0 || l > 32 {
			err := E2SmRmetIndicationHeaderFormat1ValidationError{
				field:  "VendorName",
				reason: "value length must be between 0 and 32 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RmetNodeId != nil {

		if all {
			switch v := interface{}(m.GetRmetNodeId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRmetIndicationHeaderFormat1ValidationError{
						field:  "RmetNodeId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRmetIndicationHeaderFormat1ValidationError{
						field:  "RmetNodeId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRmetNodeId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRmetIndicationHeaderFormat1ValidationError{
					field:  "RmetNodeId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRmetIndicationHeaderFormat1MultiError(errors)
	}

	return nil
}

// E2SmRmetIndicationHeaderFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmRmetIndicationHeaderFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmRmetIndicationHeaderFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetIndicationHeaderFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetIndicationHeaderFormat1MultiError) AllErrors() []error { return m }

// E2SmRmetIndicationHeaderFormat1ValidationError is the validation error
// returned by E2SmRmetIndicationHeaderFormat1.Validate if the designated
// constraints aren't met.
type E2SmRmetIndicationHeaderFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetIndicationHeaderFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetIndicationHeaderFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetIndicationHeaderFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetIndicationHeaderFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetIndicationHeaderFormat1ValidationError) ErrorName() string {
	return "E2SmRmetIndicationHeaderFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetIndicationHeaderFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetIndicationHeaderFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetIndicationHeaderFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetIndicationHeaderFormat1ValidationError{}

// Validate checks the field values on E2SmRmetIndicationMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRmetIndicationMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetIndicationMessage with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmRmetIndicationMessageMultiError, or nil if none found.
func (m *E2SmRmetIndicationMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetIndicationMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIndicationMessageFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetIndicationMessageValidationError{
					field:  "IndicationMessageFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetIndicationMessageValidationError{
					field:  "IndicationMessageFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndicationMessageFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetIndicationMessageValidationError{
				field:  "IndicationMessageFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmRmetIndicationMessageMultiError(errors)
	}

	return nil
}

// E2SmRmetIndicationMessageMultiError is an error wrapping multiple validation
// errors returned by E2SmRmetIndicationMessage.ValidateAll() if the
// designated constraints aren't met.
type E2SmRmetIndicationMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetIndicationMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetIndicationMessageMultiError) AllErrors() []error { return m }

// E2SmRmetIndicationMessageValidationError is the validation error returned by
// E2SmRmetIndicationMessage.Validate if the designated constraints aren't met.
type E2SmRmetIndicationMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetIndicationMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetIndicationMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetIndicationMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetIndicationMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetIndicationMessageValidationError) ErrorName() string {
	return "E2SmRmetIndicationMessageValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetIndicationMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetIndicationMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetIndicationMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetIndicationMessageValidationError{}

// Validate checks the field values on IndicationMessageFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndicationMessageFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndicationMessageFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndicationMessageFormatsMultiError, or nil if none found.
func (m *IndicationMessageFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicationMessageFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmRmetIndicationMessage.(type) {

	case *IndicationMessageFormats_IndicationMessageFormat1:

		if all {
			switch v := interface{}(m.GetIndicationMessageFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndicationMessageFormatsValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndicationMessageFormatsValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationMessageFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndicationMessageFormatsValidationError{
					field:  "IndicationMessageFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndicationMessageFormatsMultiError(errors)
	}

	return nil
}

// IndicationMessageFormatsMultiError is an error wrapping multiple validation
// errors returned by IndicationMessageFormats.ValidateAll() if the designated
// constraints aren't met.
type IndicationMessageFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicationMessageFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicationMessageFormatsMultiError) AllErrors() []error { return m }

// IndicationMessageFormatsValidationError is the validation error returned by
// IndicationMessageFormats.Validate if the designated constraints aren't met.
type IndicationMessageFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicationMessageFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndicationMessageFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndicationMessageFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicationMessageFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicationMessageFormatsValidationError) ErrorName() string {
	return "IndicationMessageFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e IndicationMessageFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicationMessageFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicationMessageFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicationMessageFormatsValidationError{}

// Validate checks the field values on E2SmRmetIndicationMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *E2SmRmetIndicationMessageFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetIndicationMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRmetIndicationMessageFormat1MultiError, or nil if none found.
func (m *E2SmRmetIndicationMessageFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetIndicationMessageFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetIndicationMessageFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetIndicationMessageFormat1ValidationError{
				field:  "MeasData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.CellObjId != nil {

		if all {
			switch v := interface{}(m.GetCellObjId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
						field:  "CellObjId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
						field:  "CellObjId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRmetIndicationMessageFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GranulPeriod != nil {

		if all {
			switch v := interface{}(m.GetGranulPeriod()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
						field:  "GranulPeriod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
						field:  "GranulPeriod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRmetIndicationMessageFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MeasInfoList != nil {

		if all {
			switch v := interface{}(m.GetMeasInfoList()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
						field:  "MeasInfoList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRmetIndicationMessageFormat1ValidationError{
						field:  "MeasInfoList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRmetIndicationMessageFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRmetIndicationMessageFormat1MultiError(errors)
	}

	return nil
}

// E2SmRmetIndicationMessageFormat1MultiError is an error wrapping multiple
// validation errors returned by
// E2SmRmetIndicationMessageFormat1.ValidateAll() if the designated
// constraints aren't met.
type E2SmRmetIndicationMessageFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetIndicationMessageFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetIndicationMessageFormat1MultiError) AllErrors() []error { return m }

// E2SmRmetIndicationMessageFormat1ValidationError is the validation error
// returned by E2SmRmetIndicationMessageFormat1.Validate if the designated
// constraints aren't met.
type E2SmRmetIndicationMessageFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetIndicationMessageFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetIndicationMessageFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetIndicationMessageFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetIndicationMessageFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetIndicationMessageFormat1ValidationError) ErrorName() string {
	return "E2SmRmetIndicationMessageFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetIndicationMessageFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetIndicationMessageFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetIndicationMessageFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetIndicationMessageFormat1ValidationError{}

// Validate checks the field values on E2SmRmetRanfunctionDescription with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmRmetRanfunctionDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmRmetRanfunctionDescription with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmRmetRanfunctionDescriptionMultiError, or nil if none found.
func (m *E2SmRmetRanfunctionDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmRmetRanfunctionDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRanFunctionName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRanFunctionName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmRmetRanfunctionDescriptionValidationError{
				field:  "RanFunctionName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetRicRmetNodeList()) > 1024 {
		err := E2SmRmetRanfunctionDescriptionValidationError{
			field:  "RicRmetNodeList",
			reason: "value must contain no more than 1024 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicRmetNodeList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicRmetNodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicRmetNodeList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRmetRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicRmetNodeList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetRicEventTriggerStyleList()) > 63 {
		err := E2SmRmetRanfunctionDescriptionValidationError{
			field:  "RicEventTriggerStyleList",
			reason: "value must contain no more than 63 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicEventTriggerStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRmetRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetRicReportStyleList()) > 63 {
		err := E2SmRmetRanfunctionDescriptionValidationError{
			field:  "RicReportStyleList",
			reason: "value must contain no more than 63 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicReportStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmRmetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmRmetRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmRmetRanfunctionDescriptionMultiError(errors)
	}

	return nil
}

// E2SmRmetRanfunctionDescriptionMultiError is an error wrapping multiple
// validation errors returned by E2SmRmetRanfunctionDescription.ValidateAll()
// if the designated constraints aren't met.
type E2SmRmetRanfunctionDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmRmetRanfunctionDescriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmRmetRanfunctionDescriptionMultiError) AllErrors() []error { return m }

// E2SmRmetRanfunctionDescriptionValidationError is the validation error
// returned by E2SmRmetRanfunctionDescription.Validate if the designated
// constraints aren't met.
type E2SmRmetRanfunctionDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmRmetRanfunctionDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmRmetRanfunctionDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmRmetRanfunctionDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmRmetRanfunctionDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmRmetRanfunctionDescriptionValidationError) ErrorName() string {
	return "E2SmRmetRanfunctionDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmRmetRanfunctionDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmRmetRanfunctionDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmRmetRanfunctionDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmRmetRanfunctionDescriptionValidationError{}

// Validate checks the field values on RicRmetnodeItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RicRmetnodeItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicRmetnodeItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicRmetnodeItemMultiError, or nil if none found.
func (m *RicRmetnodeItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicRmetnodeItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicRmetnodeType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicRmetnodeItemValidationError{
					field:  "RicRmetnodeType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicRmetnodeItemValidationError{
					field:  "RicRmetnodeType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicRmetnodeType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicRmetnodeItemValidationError{
				field:  "RicRmetnodeType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetCellMeasurementObjectList()) > 16384 {
		err := RicRmetnodeItemValidationError{
			field:  "CellMeasurementObjectList",
			reason: "value must contain no more than 16384 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetCellMeasurementObjectList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RicRmetnodeItemValidationError{
						field:  fmt.Sprintf("CellMeasurementObjectList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RicRmetnodeItemValidationError{
						field:  fmt.Sprintf("CellMeasurementObjectList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RicRmetnodeItemValidationError{
					field:  fmt.Sprintf("CellMeasurementObjectList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RicRmetnodeItemMultiError(errors)
	}

	return nil
}

// RicRmetnodeItemMultiError is an error wrapping multiple validation errors
// returned by RicRmetnodeItem.ValidateAll() if the designated constraints
// aren't met.
type RicRmetnodeItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicRmetnodeItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicRmetnodeItemMultiError) AllErrors() []error { return m }

// RicRmetnodeItemValidationError is the validation error returned by
// RicRmetnodeItem.Validate if the designated constraints aren't met.
type RicRmetnodeItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicRmetnodeItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicRmetnodeItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicRmetnodeItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicRmetnodeItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicRmetnodeItemValidationError) ErrorName() string { return "RicRmetnodeItemValidationError" }

// Error satisfies the builtin error interface
func (e RicRmetnodeItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicRmetnodeItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicRmetnodeItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicRmetnodeItemValidationError{}

// Validate checks the field values on CellMeasurementObjectItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CellMeasurementObjectItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellMeasurementObjectItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CellMeasurementObjectItemMultiError, or nil if none found.
func (m *CellMeasurementObjectItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CellMeasurementObjectItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCellObjectId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellObjectId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellObjectId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjectId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CellMeasurementObjectItemValidationError{
				field:  "CellObjectId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCellGlobalId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellGlobalId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CellMeasurementObjectItemValidationError{
					field:  "CellGlobalId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellGlobalId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CellMeasurementObjectItemValidationError{
				field:  "CellGlobalId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CellMeasurementObjectItemMultiError(errors)
	}

	return nil
}

// CellMeasurementObjectItemMultiError is an error wrapping multiple validation
// errors returned by CellMeasurementObjectItem.ValidateAll() if the
// designated constraints aren't met.
type CellMeasurementObjectItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellMeasurementObjectItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellMeasurementObjectItemMultiError) AllErrors() []error { return m }

// CellMeasurementObjectItemValidationError is the validation error returned by
// CellMeasurementObjectItem.Validate if the designated constraints aren't met.
type CellMeasurementObjectItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellMeasurementObjectItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellMeasurementObjectItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellMeasurementObjectItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellMeasurementObjectItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellMeasurementObjectItemValidationError) ErrorName() string {
	return "CellMeasurementObjectItemValidationError"
}

// Error satisfies the builtin error interface
func (e CellMeasurementObjectItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellMeasurementObjectItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellMeasurementObjectItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellMeasurementObjectItemValidationError{}

// Validate checks the field values on RicEventTriggerStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicEventTriggerStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicEventTriggerStyleItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicEventTriggerStyleItemMultiError, or nil if none found.
func (m *RicEventTriggerStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicEventTriggerStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicEventTriggerStyleItemMultiError(errors)
	}

	return nil
}

// RicEventTriggerStyleItemMultiError is an error wrapping multiple validation
// errors returned by RicEventTriggerStyleItem.ValidateAll() if the designated
// constraints aren't met.
type RicEventTriggerStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicEventTriggerStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicEventTriggerStyleItemMultiError) AllErrors() []error { return m }

// RicEventTriggerStyleItemValidationError is the validation error returned by
// RicEventTriggerStyleItem.Validate if the designated constraints aren't met.
type RicEventTriggerStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicEventTriggerStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicEventTriggerStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicEventTriggerStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicEventTriggerStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicEventTriggerStyleItemValidationError) ErrorName() string {
	return "RicEventTriggerStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicEventTriggerStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicEventTriggerStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicEventTriggerStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicEventTriggerStyleItemValidationError{}

// Validate checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicReportStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicReportStyleItemMultiError, or nil if none found.
func (m *RicReportStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicReportStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicReportStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicReportStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicActionFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicActionFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicActionFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoActionList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoActionList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "MeasInfoActionList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationHeaderFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationHeaderFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationHeaderFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationMessageFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationMessageFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationMessageFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicReportStyleItemMultiError(errors)
	}

	return nil
}

// RicReportStyleItemMultiError is an error wrapping multiple validation errors
// returned by RicReportStyleItem.ValidateAll() if the designated constraints
// aren't met.
type RicReportStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicReportStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicReportStyleItemMultiError) AllErrors() []error { return m }

// RicReportStyleItemValidationError is the validation error returned by
// RicReportStyleItem.Validate if the designated constraints aren't met.
type RicReportStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicReportStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicReportStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicReportStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicReportStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicReportStyleItemValidationError) ErrorName() string {
	return "RicReportStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicReportStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicReportStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicReportStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicReportStyleItemValidationError{}

// Validate checks the field values on RicStyleName with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleNameMultiError, or
// nil if none found.
func (m *RicStyleName) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := RicStyleNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicStyleNameMultiError(errors)
	}

	return nil
}

// RicStyleNameMultiError is an error wrapping multiple validation errors
// returned by RicStyleName.ValidateAll() if the designated constraints aren't met.
type RicStyleNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleNameMultiError) AllErrors() []error { return m }

// RicStyleNameValidationError is the validation error returned by
// RicStyleName.Validate if the designated constraints aren't met.
type RicStyleNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleNameValidationError) ErrorName() string { return "RicStyleNameValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleNameValidationError{}

// Validate checks the field values on CellObjectId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellObjectId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellObjectId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellObjectIdMultiError, or
// nil if none found.
func (m *CellObjectId) ValidateAll() error {
	return m.validate(true)
}

func (m *CellObjectId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 0 || l > 400 {
		err := CellObjectIdValidationError{
			field:  "Value",
			reason: "value length must be between 0 and 400 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CellObjectIdMultiError(errors)
	}

	return nil
}

// CellObjectIdMultiError is an error wrapping multiple validation errors
// returned by CellObjectId.ValidateAll() if the designated constraints aren't met.
type CellObjectIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellObjectIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellObjectIdMultiError) AllErrors() []error { return m }

// CellObjectIdValidationError is the validation error returned by
// CellObjectId.Validate if the designated constraints aren't met.
type CellObjectIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellObjectIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellObjectIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellObjectIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellObjectIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellObjectIdValidationError) ErrorName() string { return "CellObjectIdValidationError" }

// Error satisfies the builtin error interface
func (e CellObjectIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellObjectId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellObjectIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellObjectIdValidationError{}

// Validate checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeNameMultiError, or nil if none found.
func (m *MeasurementTypeName) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := MeasurementTypeNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeNameMultiError(errors)
	}

	return nil
}

// MeasurementTypeNameMultiError is an error wrapping multiple validation
// errors returned by MeasurementTypeName.ValidateAll() if the designated
// constraints aren't met.
type MeasurementTypeNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeNameMultiError) AllErrors() []error { return m }

// MeasurementTypeNameValidationError is the validation error returned by
// MeasurementTypeName.Validate if the designated constraints aren't met.
type MeasurementTypeNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeNameValidationError) ErrorName() string {
	return "MeasurementTypeNameValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeNameValidationError{}

// Validate checks the field values on UeIdentity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UeIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UeIdentity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UeIdentityMultiError, or
// nil if none found.
func (m *UeIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *UeIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return UeIdentityMultiError(errors)
	}

	return nil
}

// UeIdentityMultiError is an error wrapping multiple validation errors
// returned by UeIdentity.ValidateAll() if the designated constraints aren't met.
type UeIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeIdentityMultiError) AllErrors() []error { return m }

// UeIdentityValidationError is the validation error returned by
// UeIdentity.Validate if the designated constraints aren't met.
type UeIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeIdentityValidationError) ErrorName() string { return "UeIdentityValidationError" }

// Error satisfies the builtin error interface
func (e UeIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeIdentityValidationError{}

// Validate checks the field values on PlmnIdentity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlmnIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlmnIdentity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlmnIdentityMultiError, or
// nil if none found.
func (m *PlmnIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *PlmnIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 3 {
		err := PlmnIdentityValidationError{
			field:  "Value",
			reason: "value length must be 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PlmnIdentityMultiError(errors)
	}

	return nil
}

// PlmnIdentityMultiError is an error wrapping multiple validation errors
// returned by PlmnIdentity.ValidateAll() if the designated constraints aren't met.
type PlmnIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlmnIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlmnIdentityMultiError) AllErrors() []error { return m }

// PlmnIdentityValidationError is the validation error returned by
// PlmnIdentity.Validate if the designated constraints aren't met.
type PlmnIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlmnIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlmnIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlmnIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlmnIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlmnIdentityValidationError) ErrorName() string { return "PlmnIdentityValidationError" }

// Error satisfies the builtin error interface
func (e PlmnIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlmnIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlmnIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlmnIdentityValidationError{}

// Validate checks the field values on TimeStamp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeStamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeStamp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeStampMultiError, or nil
// if none found.
func (m *TimeStamp) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeStamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 4 {
		err := TimeStampValidationError{
			field:  "Value",
			reason: "value length must be 4 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TimeStampMultiError(errors)
	}

	return nil
}

// TimeStampMultiError is an error wrapping multiple validation errors returned
// by TimeStamp.ValidateAll() if the designated constraints aren't met.
type TimeStampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeStampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeStampMultiError) AllErrors() []error { return m }

// TimeStampValidationError is the validation error returned by
// TimeStamp.Validate if the designated constraints aren't met.
type TimeStampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeStampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeStampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeStampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeStampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeStampValidationError) ErrorName() string { return "TimeStampValidationError" }

// Error satisfies the builtin error interface
func (e TimeStampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeStamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeStampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeStampValidationError{}

// Validate checks the field values on EutracellIdentity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EutracellIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EutracellIdentity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EutracellIdentityMultiError, or nil if none found.
func (m *EutracellIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *EutracellIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EutracellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EutracellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EutracellIdentityValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EutracellIdentityMultiError(errors)
	}

	return nil
}

// EutracellIdentityMultiError is an error wrapping multiple validation errors
// returned by EutracellIdentity.ValidateAll() if the designated constraints
// aren't met.
type EutracellIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EutracellIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EutracellIdentityMultiError) AllErrors() []error { return m }

// EutracellIdentityValidationError is the validation error returned by
// EutracellIdentity.Validate if the designated constraints aren't met.
type EutracellIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EutracellIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EutracellIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EutracellIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EutracellIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EutracellIdentityValidationError) ErrorName() string {
	return "EutracellIdentityValidationError"
}

// Error satisfies the builtin error interface
func (e EutracellIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEutracellIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EutracellIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EutracellIdentityValidationError{}

// Validate checks the field values on NrcellIdentity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NrcellIdentity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NrcellIdentity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NrcellIdentityMultiError,
// or nil if none found.
func (m *NrcellIdentity) ValidateAll() error {
	return m.validate(true)
}

func (m *NrcellIdentity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NrcellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NrcellIdentityValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NrcellIdentityValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NrcellIdentityMultiError(errors)
	}

	return nil
}

// NrcellIdentityMultiError is an error wrapping multiple validation errors
// returned by NrcellIdentity.ValidateAll() if the designated constraints
// aren't met.
type NrcellIdentityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NrcellIdentityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NrcellIdentityMultiError) AllErrors() []error { return m }

// NrcellIdentityValidationError is the validation error returned by
// NrcellIdentity.Validate if the designated constraints aren't met.
type NrcellIdentityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NrcellIdentityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NrcellIdentityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NrcellIdentityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NrcellIdentityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NrcellIdentityValidationError) ErrorName() string { return "NrcellIdentityValidationError" }

// Error satisfies the builtin error interface
func (e NrcellIdentityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNrcellIdentity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NrcellIdentityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NrcellIdentityValidationError{}

// Validate checks the field values on Uetag with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Uetag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uetag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UetagMultiError, or nil if none found.
func (m *Uetag) ValidateAll() error {
	return m.validate(true)
}

func (m *Uetag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 0 || l > 150 {
		err := UetagValidationError{
			field:  "Value",
			reason: "value length must be between 0 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UetagMultiError(errors)
	}

	return nil
}

// UetagMultiError is an error wrapping multiple validation errors returned by
// Uetag.ValidateAll() if the designated constraints aren't met.
type UetagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UetagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UetagMultiError) AllErrors() []error { return m }

// UetagValidationError is the validation error returned by Uetag.Validate if
// the designated constraints aren't met.
type UetagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UetagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UetagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UetagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UetagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UetagValidationError) ErrorName() string { return "UetagValidationError" }

// Error satisfies the builtin error interface
func (e UetagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUetag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UetagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UetagValidationError{}
