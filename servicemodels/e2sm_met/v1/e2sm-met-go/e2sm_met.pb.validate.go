// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: e2sm_met/v1/e2sm_met.proto

package e2sm_met_go

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CellObjectId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellObjectId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellObjectId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellObjectIdMultiError, or
// nil if none found.
func (m *CellObjectId) ValidateAll() error {
	return m.validate(true)
}

func (m *CellObjectId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := CellObjectIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CellObjectIdMultiError(errors)
	}

	return nil
}

// CellObjectIdMultiError is an error wrapping multiple validation errors
// returned by CellObjectId.ValidateAll() if the designated constraints aren't met.
type CellObjectIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellObjectIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellObjectIdMultiError) AllErrors() []error { return m }

// CellObjectIdValidationError is the validation error returned by
// CellObjectId.Validate if the designated constraints aren't met.
type CellObjectIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellObjectIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellObjectIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellObjectIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellObjectIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellObjectIdValidationError) ErrorName() string { return "CellObjectIdValidationError" }

// Error satisfies the builtin error interface
func (e CellObjectIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellObjectId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellObjectIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellObjectIdValidationError{}

// Validate checks the field values on GranularityPeriod with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GranularityPeriod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GranularityPeriod with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GranularityPeriodMultiError, or nil if none found.
func (m *GranularityPeriod) ValidateAll() error {
	return m.validate(true)
}

func (m *GranularityPeriod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := GranularityPeriodValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GranularityPeriodMultiError(errors)
	}

	return nil
}

// GranularityPeriodMultiError is an error wrapping multiple validation errors
// returned by GranularityPeriod.ValidateAll() if the designated constraints
// aren't met.
type GranularityPeriodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GranularityPeriodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GranularityPeriodMultiError) AllErrors() []error { return m }

// GranularityPeriodValidationError is the validation error returned by
// GranularityPeriod.Validate if the designated constraints aren't met.
type GranularityPeriodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GranularityPeriodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GranularityPeriodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GranularityPeriodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GranularityPeriodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GranularityPeriodValidationError) ErrorName() string {
	return "GranularityPeriodValidationError"
}

// Error satisfies the builtin error interface
func (e GranularityPeriodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGranularityPeriod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GranularityPeriodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GranularityPeriodValidationError{}

// Validate checks the field values on SubscriptionId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubscriptionId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptionIdMultiError,
// or nil if none found.
func (m *SubscriptionId) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := SubscriptionIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SubscriptionIdMultiError(errors)
	}

	return nil
}

// SubscriptionIdMultiError is an error wrapping multiple validation errors
// returned by SubscriptionId.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionIdMultiError) AllErrors() []error { return m }

// SubscriptionIdValidationError is the validation error returned by
// SubscriptionId.Validate if the designated constraints aren't met.
type SubscriptionIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionIdValidationError) ErrorName() string { return "SubscriptionIdValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionIdValidationError{}

// Validate checks the field values on GlobalMetnodeId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GlobalMetnodeId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalMetnodeId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalMetnodeIdMultiError, or nil if none found.
func (m *GlobalMetnodeId) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalMetnodeId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := GlobalMetnodeIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GlobalMetnodeIdMultiError(errors)
	}

	return nil
}

// GlobalMetnodeIdMultiError is an error wrapping multiple validation errors
// returned by GlobalMetnodeId.ValidateAll() if the designated constraints
// aren't met.
type GlobalMetnodeIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalMetnodeIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalMetnodeIdMultiError) AllErrors() []error { return m }

// GlobalMetnodeIdValidationError is the validation error returned by
// GlobalMetnodeId.Validate if the designated constraints aren't met.
type GlobalMetnodeIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalMetnodeIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalMetnodeIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalMetnodeIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalMetnodeIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalMetnodeIdValidationError) ErrorName() string { return "GlobalMetnodeIdValidationError" }

// Error satisfies the builtin error interface
func (e GlobalMetnodeIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalMetnodeId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalMetnodeIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalMetnodeIdValidationError{}

// Validate checks the field values on RanfunctionName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RanfunctionName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RanfunctionName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RanfunctionNameMultiError, or nil if none found.
func (m *RanfunctionName) ValidateAll() error {
	return m.validate(true)
}

func (m *RanfunctionName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetRanFunctionShortName()); l < 1 || l > 150 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionShortName",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRanFunctionE2SmOid()); l < 1 || l > 1000 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionE2SmOid",
			reason: "value length must be between 1 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRanFunctionDescription()); l < 1 || l > 150 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionDescription",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RanfunctionNameMultiError(errors)
	}

	return nil
}

// RanfunctionNameMultiError is an error wrapping multiple validation errors
// returned by RanfunctionName.ValidateAll() if the designated constraints
// aren't met.
type RanfunctionNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RanfunctionNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RanfunctionNameMultiError) AllErrors() []error { return m }

// RanfunctionNameValidationError is the validation error returned by
// RanfunctionName.Validate if the designated constraints aren't met.
type RanfunctionNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RanfunctionNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RanfunctionNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RanfunctionNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RanfunctionNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RanfunctionNameValidationError) ErrorName() string { return "RanfunctionNameValidationError" }

// Error satisfies the builtin error interface
func (e RanfunctionNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRanfunctionName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RanfunctionNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RanfunctionNameValidationError{}

// Validate checks the field values on MaxofUe with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxofUe) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxofUe with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MaxofUeMultiError, or nil if none found.
func (m *MaxofUe) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxofUe) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65535 {
		err := MaxofUeValidationError{
			field:  "Value",
			reason: "value must equal 65535",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxofUeMultiError(errors)
	}

	return nil
}

// MaxofUeMultiError is an error wrapping multiple validation errors returned
// by MaxofUe.ValidateAll() if the designated constraints aren't met.
type MaxofUeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxofUeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxofUeMultiError) AllErrors() []error { return m }

// MaxofUeValidationError is the validation error returned by MaxofUe.Validate
// if the designated constraints aren't met.
type MaxofUeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxofUeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxofUeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxofUeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxofUeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxofUeValidationError) ErrorName() string { return "MaxofUeValidationError" }

// Error satisfies the builtin error interface
func (e MaxofUeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxofUe.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxofUeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxofUeValidationError{}

// Validate checks the field values on Ueid with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Ueid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ueid with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UeidMultiError, or nil if none found.
func (m *Ueid) ValidateAll() error {
	return m.validate(true)
}

func (m *Ueid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := UeidValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UeidMultiError(errors)
	}

	return nil
}

// UeidMultiError is an error wrapping multiple validation errors returned by
// Ueid.ValidateAll() if the designated constraints aren't met.
type UeidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeidMultiError) AllErrors() []error { return m }

// UeidValidationError is the validation error returned by Ueid.Validate if the
// designated constraints aren't met.
type UeidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeidValidationError) ErrorName() string { return "UeidValidationError" }

// Error satisfies the builtin error interface
func (e UeidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeidValidationError{}

// Validate checks the field values on Ueitem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Ueitem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ueitem with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UeitemMultiError, or nil if none found.
func (m *Ueitem) ValidateAll() error {
	return m.validate(true)
}

func (m *Ueitem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UeitemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UeitemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UeitemValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.UeTag != nil {

		if all {
			switch v := interface{}(m.GetUeTag()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeitemValidationError{
						field:  "UeTag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeitemValidationError{
						field:  "UeTag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUeTag()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeitemValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UeitemMultiError(errors)
	}

	return nil
}

// UeitemMultiError is an error wrapping multiple validation errors returned by
// Ueitem.ValidateAll() if the designated constraints aren't met.
type UeitemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeitemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeitemMultiError) AllErrors() []error { return m }

// UeitemValidationError is the validation error returned by Ueitem.Validate if
// the designated constraints aren't met.
type UeitemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeitemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeitemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeitemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeitemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeitemValidationError) ErrorName() string { return "UeitemValidationError" }

// Error satisfies the builtin error interface
func (e UeitemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeitem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeitemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeitemValidationError{}

// Validate checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoListMultiError, or nil if none found.
func (m *MeasurementInfoList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoListMultiError(errors)
	}

	return nil
}

// MeasurementInfoListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoList.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoListMultiError) AllErrors() []error { return m }

// MeasurementInfoListValidationError is the validation error returned by
// MeasurementInfoList.Validate if the designated constraints aren't met.
type MeasurementInfoListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoListValidationError) ErrorName() string {
	return "MeasurementInfoListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoListValidationError{}

// Validate checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoItemMultiError, or nil if none found.
func (m *MeasurementInfoItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := MeasurementInfoItemValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementInfoItemMultiError(errors)
	}

	return nil
}

// MeasurementInfoItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoItemMultiError) AllErrors() []error { return m }

// MeasurementInfoItemValidationError is the validation error returned by
// MeasurementInfoItem.Validate if the designated constraints aren't met.
type MeasurementInfoItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoItemValidationError) ErrorName() string {
	return "MeasurementInfoItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoItemValidationError{}

// Validate checks the field values on MeasurementData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementDataMultiError, or nil if none found.
func (m *MeasurementData) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementDataValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementDataMultiError(errors)
	}

	return nil
}

// MeasurementDataMultiError is an error wrapping multiple validation errors
// returned by MeasurementData.ValidateAll() if the designated constraints
// aren't met.
type MeasurementDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementDataMultiError) AllErrors() []error { return m }

// MeasurementDataValidationError is the validation error returned by
// MeasurementData.Validate if the designated constraints aren't met.
type MeasurementDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementDataValidationError) ErrorName() string { return "MeasurementDataValidationError" }

// Error satisfies the builtin error interface
func (e MeasurementDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementDataValidationError{}

// Validate checks the field values on MeasurementRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordMultiError, or nil if none found.
func (m *MeasurementRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementRecordValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUeTag()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeTag()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementRecordValidationError{
				field:  "UeTag",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetMeasRecordItem()); l < 1 || l > 65535 {
		err := MeasurementRecordValidationError{
			field:  "MeasRecordItem",
			reason: "value must contain between 1 and 65535 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMeasRecordItem() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementRecordValidationError{
						field:  fmt.Sprintf("MeasRecordItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementRecordValidationError{
						field:  fmt.Sprintf("MeasRecordItem[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementRecordValidationError{
					field:  fmt.Sprintf("MeasRecordItem[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementRecordMultiError(errors)
	}

	return nil
}

// MeasurementRecordMultiError is an error wrapping multiple validation errors
// returned by MeasurementRecord.ValidateAll() if the designated constraints
// aren't met.
type MeasurementRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordMultiError) AllErrors() []error { return m }

// MeasurementRecordValidationError is the validation error returned by
// MeasurementRecord.Validate if the designated constraints aren't met.
type MeasurementRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordValidationError) ErrorName() string {
	return "MeasurementRecordValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordValidationError{}

// Validate checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecordItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordItemMultiError, or nil if none found.
func (m *MeasurementRecordItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecordItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.MeasurementRecordItem.(type) {

	case *MeasurementRecordItem_Integer:
		// no validation rules for Integer

	case *MeasurementRecordItem_NoValue:
		// no validation rules for NoValue

	}

	if len(errors) > 0 {
		return MeasurementRecordItemMultiError(errors)
	}

	return nil
}

// MeasurementRecordItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementRecordItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementRecordItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordItemMultiError) AllErrors() []error { return m }

// MeasurementRecordItemValidationError is the validation error returned by
// MeasurementRecordItem.Validate if the designated constraints aren't met.
type MeasurementRecordItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordItemValidationError) ErrorName() string {
	return "MeasurementRecordItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecordItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordItemValidationError{}

// Validate checks the field values on MeasurementInfoActionList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionListMultiError, or nil if none found.
func (m *MeasurementInfoActionList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoActionListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoActionListMultiError(errors)
	}

	return nil
}

// MeasurementInfoActionListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionList.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionListMultiError) AllErrors() []error { return m }

// MeasurementInfoActionListValidationError is the validation error returned by
// MeasurementInfoActionList.Validate if the designated constraints aren't met.
type MeasurementInfoActionListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionListValidationError) ErrorName() string {
	return "MeasurementInfoActionListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionListValidationError{}

// Validate checks the field values on MeasurementInfoActionItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionItemMultiError, or nil if none found.
func (m *MeasurementInfoActionItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoActionItemValidationError{
				field:  "MeasName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.MeasId != nil {

		if all {
			switch v := interface{}(m.GetMeasId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoActionItemValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoActionItemValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoActionItemValidationError{
					field:  "MeasId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoActionItemMultiError(errors)
	}

	return nil
}

// MeasurementInfoActionItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionItem.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionItemMultiError) AllErrors() []error { return m }

// MeasurementInfoActionItemValidationError is the validation error returned by
// MeasurementInfoActionItem.Validate if the designated constraints aren't met.
type MeasurementInfoActionItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionItemValidationError) ErrorName() string {
	return "MeasurementInfoActionItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionItemValidationError{}

// Validate checks the field values on MeasurementTypeId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeIdMultiError, or nil if none found.
func (m *MeasurementTypeId) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 65536 {
		err := MeasurementTypeIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 65536]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeIdMultiError(errors)
	}

	return nil
}

// MeasurementTypeIdMultiError is an error wrapping multiple validation errors
// returned by MeasurementTypeId.ValidateAll() if the designated constraints
// aren't met.
type MeasurementTypeIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeIdMultiError) AllErrors() []error { return m }

// MeasurementTypeIdValidationError is the validation error returned by
// MeasurementTypeId.Validate if the designated constraints aren't met.
type MeasurementTypeIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeIdValidationError) ErrorName() string {
	return "MeasurementTypeIdValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeIdValidationError{}

// Validate checks the field values on E2SmMetEventTriggerDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetEventTriggerDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetEventTriggerDefinition with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmMetEventTriggerDefinitionMultiError, or nil if none found.
func (m *E2SmMetEventTriggerDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetEventTriggerDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDefinitionFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDefinitionFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetEventTriggerDefinitionValidationError{
				field:  "EventDefinitionFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmMetEventTriggerDefinitionMultiError(errors)
	}

	return nil
}

// E2SmMetEventTriggerDefinitionMultiError is an error wrapping multiple
// validation errors returned by E2SmMetEventTriggerDefinition.ValidateAll()
// if the designated constraints aren't met.
type E2SmMetEventTriggerDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetEventTriggerDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetEventTriggerDefinitionMultiError) AllErrors() []error { return m }

// E2SmMetEventTriggerDefinitionValidationError is the validation error
// returned by E2SmMetEventTriggerDefinition.Validate if the designated
// constraints aren't met.
type E2SmMetEventTriggerDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetEventTriggerDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetEventTriggerDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetEventTriggerDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetEventTriggerDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetEventTriggerDefinitionValidationError) ErrorName() string {
	return "E2SmMetEventTriggerDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetEventTriggerDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetEventTriggerDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetEventTriggerDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetEventTriggerDefinitionValidationError{}

// Validate checks the field values on EventTriggerDefinitionFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventTriggerDefinitionFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventTriggerDefinitionFormats with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EventTriggerDefinitionFormatsMultiError, or nil if none found.
func (m *EventTriggerDefinitionFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *EventTriggerDefinitionFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmMetEventTriggerDefinition.(type) {

	case *EventTriggerDefinitionFormats_EventDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetEventDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventTriggerDefinitionFormatsValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventTriggerDefinitionFormatsValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEventDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventTriggerDefinitionFormatsValidationError{
					field:  "EventDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EventTriggerDefinitionFormatsMultiError(errors)
	}

	return nil
}

// EventTriggerDefinitionFormatsMultiError is an error wrapping multiple
// validation errors returned by EventTriggerDefinitionFormats.ValidateAll()
// if the designated constraints aren't met.
type EventTriggerDefinitionFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventTriggerDefinitionFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventTriggerDefinitionFormatsMultiError) AllErrors() []error { return m }

// EventTriggerDefinitionFormatsValidationError is the validation error
// returned by EventTriggerDefinitionFormats.Validate if the designated
// constraints aren't met.
type EventTriggerDefinitionFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventTriggerDefinitionFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventTriggerDefinitionFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventTriggerDefinitionFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventTriggerDefinitionFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventTriggerDefinitionFormatsValidationError) ErrorName() string {
	return "EventTriggerDefinitionFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e EventTriggerDefinitionFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventTriggerDefinitionFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventTriggerDefinitionFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventTriggerDefinitionFormatsValidationError{}

// Validate checks the field values on E2SmMetEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *E2SmMetEventTriggerDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// E2SmMetEventTriggerDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmMetEventTriggerDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetEventTriggerDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReportingPeriod

	if len(errors) > 0 {
		return E2SmMetEventTriggerDefinitionFormat1MultiError(errors)
	}

	return nil
}

// E2SmMetEventTriggerDefinitionFormat1MultiError is an error wrapping multiple
// validation errors returned by
// E2SmMetEventTriggerDefinitionFormat1.ValidateAll() if the designated
// constraints aren't met.
type E2SmMetEventTriggerDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetEventTriggerDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetEventTriggerDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmMetEventTriggerDefinitionFormat1ValidationError is the validation error
// returned by E2SmMetEventTriggerDefinitionFormat1.Validate if the designated
// constraints aren't met.
type E2SmMetEventTriggerDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetEventTriggerDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetEventTriggerDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetEventTriggerDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetEventTriggerDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetEventTriggerDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmMetEventTriggerDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetEventTriggerDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetEventTriggerDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetEventTriggerDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetEventTriggerDefinitionFormat1ValidationError{}

// Validate checks the field values on E2SmMetActionDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetActionDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetActionDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmMetActionDefinitionMultiError, or nil if none found.
func (m *E2SmMetActionDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetActionDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetActionDefinitionValidationError{
				field:  "RicStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActionDefinitionFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionValidationError{
					field:  "ActionDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionValidationError{
					field:  "ActionDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionDefinitionFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetActionDefinitionValidationError{
				field:  "ActionDefinitionFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmMetActionDefinitionMultiError(errors)
	}

	return nil
}

// E2SmMetActionDefinitionMultiError is an error wrapping multiple validation
// errors returned by E2SmMetActionDefinition.ValidateAll() if the designated
// constraints aren't met.
type E2SmMetActionDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetActionDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetActionDefinitionMultiError) AllErrors() []error { return m }

// E2SmMetActionDefinitionValidationError is the validation error returned by
// E2SmMetActionDefinition.Validate if the designated constraints aren't met.
type E2SmMetActionDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetActionDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetActionDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetActionDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetActionDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetActionDefinitionValidationError) ErrorName() string {
	return "E2SmMetActionDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetActionDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetActionDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetActionDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetActionDefinitionValidationError{}

// Validate checks the field values on ActionDefinitionFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActionDefinitionFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionDefinitionFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActionDefinitionFormatsMultiError, or nil if none found.
func (m *ActionDefinitionFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionDefinitionFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmMetActionDefinition.(type) {

	case *ActionDefinitionFormats_ActionDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetActionDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDefinitionFormatsValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDefinitionFormatsValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDefinitionFormatsValidationError{
					field:  "ActionDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionDefinitionFormatsMultiError(errors)
	}

	return nil
}

// ActionDefinitionFormatsMultiError is an error wrapping multiple validation
// errors returned by ActionDefinitionFormats.ValidateAll() if the designated
// constraints aren't met.
type ActionDefinitionFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionDefinitionFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionDefinitionFormatsMultiError) AllErrors() []error { return m }

// ActionDefinitionFormatsValidationError is the validation error returned by
// ActionDefinitionFormats.Validate if the designated constraints aren't met.
type ActionDefinitionFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionDefinitionFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionDefinitionFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionDefinitionFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionDefinitionFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionDefinitionFormatsValidationError) ErrorName() string {
	return "ActionDefinitionFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e ActionDefinitionFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionDefinitionFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionDefinitionFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionDefinitionFormatsValidationError{}

// Validate checks the field values on E2SmMetActionDefinitionFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetActionDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetActionDefinitionFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmMetActionDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmMetActionDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetActionDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCellObjId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetActionDefinitionFormat1ValidationError{
				field:  "CellObjId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetActionDefinitionFormat1ValidationError{
				field:  "MeasInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGranulPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetActionDefinitionFormat1ValidationError{
				field:  "GranulPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetActionDefinitionFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmMetActionDefinitionFormat1MultiError(errors)
	}

	return nil
}

// E2SmMetActionDefinitionFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmMetActionDefinitionFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmMetActionDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetActionDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetActionDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmMetActionDefinitionFormat1ValidationError is the validation error
// returned by E2SmMetActionDefinitionFormat1.Validate if the designated
// constraints aren't met.
type E2SmMetActionDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetActionDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetActionDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetActionDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetActionDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetActionDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmMetActionDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetActionDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetActionDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetActionDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetActionDefinitionFormat1ValidationError{}

// Validate checks the field values on E2SmMetIndicationHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetIndicationHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetIndicationHeader with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmMetIndicationHeaderMultiError, or nil if none found.
func (m *E2SmMetIndicationHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetIndicationHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIndicationHeaderFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetIndicationHeaderValidationError{
					field:  "IndicationHeaderFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetIndicationHeaderValidationError{
					field:  "IndicationHeaderFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndicationHeaderFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetIndicationHeaderValidationError{
				field:  "IndicationHeaderFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmMetIndicationHeaderMultiError(errors)
	}

	return nil
}

// E2SmMetIndicationHeaderMultiError is an error wrapping multiple validation
// errors returned by E2SmMetIndicationHeader.ValidateAll() if the designated
// constraints aren't met.
type E2SmMetIndicationHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetIndicationHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetIndicationHeaderMultiError) AllErrors() []error { return m }

// E2SmMetIndicationHeaderValidationError is the validation error returned by
// E2SmMetIndicationHeader.Validate if the designated constraints aren't met.
type E2SmMetIndicationHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetIndicationHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetIndicationHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetIndicationHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetIndicationHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetIndicationHeaderValidationError) ErrorName() string {
	return "E2SmMetIndicationHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetIndicationHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetIndicationHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetIndicationHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetIndicationHeaderValidationError{}

// Validate checks the field values on IndicationHeaderFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndicationHeaderFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndicationHeaderFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndicationHeaderFormatsMultiError, or nil if none found.
func (m *IndicationHeaderFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicationHeaderFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmMetIndicationHeader.(type) {

	case *IndicationHeaderFormats_IndicationHeaderFormat1:

		if all {
			switch v := interface{}(m.GetIndicationHeaderFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndicationHeaderFormatsValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndicationHeaderFormatsValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationHeaderFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndicationHeaderFormatsValidationError{
					field:  "IndicationHeaderFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndicationHeaderFormatsMultiError(errors)
	}

	return nil
}

// IndicationHeaderFormatsMultiError is an error wrapping multiple validation
// errors returned by IndicationHeaderFormats.ValidateAll() if the designated
// constraints aren't met.
type IndicationHeaderFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicationHeaderFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicationHeaderFormatsMultiError) AllErrors() []error { return m }

// IndicationHeaderFormatsValidationError is the validation error returned by
// IndicationHeaderFormats.Validate if the designated constraints aren't met.
type IndicationHeaderFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicationHeaderFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndicationHeaderFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndicationHeaderFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicationHeaderFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicationHeaderFormatsValidationError) ErrorName() string {
	return "IndicationHeaderFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e IndicationHeaderFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicationHeaderFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicationHeaderFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicationHeaderFormatsValidationError{}

// Validate checks the field values on E2SmMetIndicationHeaderFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetIndicationHeaderFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetIndicationHeaderFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmMetIndicationHeaderFormat1MultiError, or nil if none found.
func (m *E2SmMetIndicationHeaderFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetIndicationHeaderFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetColletStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetColletStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetIndicationHeaderFormat1ValidationError{
				field:  "ColletStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetIndicationHeaderFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetIndicationHeaderFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetIndicationHeaderFormat1ValidationError{
				field:  "MeasInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.FileFormatversion != nil {

		if l := utf8.RuneCountInString(m.GetFileFormatversion()); l < 0 || l > 15 {
			err := E2SmMetIndicationHeaderFormat1ValidationError{
				field:  "FileFormatversion",
				reason: "value length must be between 0 and 15 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.SenderName != nil {

		if l := utf8.RuneCountInString(m.GetSenderName()); l < 0 || l > 400 {
			err := E2SmMetIndicationHeaderFormat1ValidationError{
				field:  "SenderName",
				reason: "value length must be between 0 and 400 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.MetNodeId != nil {

		if all {
			switch v := interface{}(m.GetMetNodeId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmMetIndicationHeaderFormat1ValidationError{
						field:  "MetNodeId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmMetIndicationHeaderFormat1ValidationError{
						field:  "MetNodeId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetNodeId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmMetIndicationHeaderFormat1ValidationError{
					field:  "MetNodeId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmMetIndicationHeaderFormat1MultiError(errors)
	}

	return nil
}

// E2SmMetIndicationHeaderFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmMetIndicationHeaderFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmMetIndicationHeaderFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetIndicationHeaderFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetIndicationHeaderFormat1MultiError) AllErrors() []error { return m }

// E2SmMetIndicationHeaderFormat1ValidationError is the validation error
// returned by E2SmMetIndicationHeaderFormat1.Validate if the designated
// constraints aren't met.
type E2SmMetIndicationHeaderFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetIndicationHeaderFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetIndicationHeaderFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetIndicationHeaderFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetIndicationHeaderFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetIndicationHeaderFormat1ValidationError) ErrorName() string {
	return "E2SmMetIndicationHeaderFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetIndicationHeaderFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetIndicationHeaderFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetIndicationHeaderFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetIndicationHeaderFormat1ValidationError{}

// Validate checks the field values on E2SmMetIndicationMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetIndicationMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetIndicationMessage with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmMetIndicationMessageMultiError, or nil if none found.
func (m *E2SmMetIndicationMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetIndicationMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIndicationMessageFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetIndicationMessageValidationError{
					field:  "IndicationMessageFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetIndicationMessageValidationError{
					field:  "IndicationMessageFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndicationMessageFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetIndicationMessageValidationError{
				field:  "IndicationMessageFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmMetIndicationMessageMultiError(errors)
	}

	return nil
}

// E2SmMetIndicationMessageMultiError is an error wrapping multiple validation
// errors returned by E2SmMetIndicationMessage.ValidateAll() if the designated
// constraints aren't met.
type E2SmMetIndicationMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetIndicationMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetIndicationMessageMultiError) AllErrors() []error { return m }

// E2SmMetIndicationMessageValidationError is the validation error returned by
// E2SmMetIndicationMessage.Validate if the designated constraints aren't met.
type E2SmMetIndicationMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetIndicationMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetIndicationMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetIndicationMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetIndicationMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetIndicationMessageValidationError) ErrorName() string {
	return "E2SmMetIndicationMessageValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetIndicationMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetIndicationMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetIndicationMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetIndicationMessageValidationError{}

// Validate checks the field values on IndicationMessageFormats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndicationMessageFormats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndicationMessageFormats with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndicationMessageFormatsMultiError, or nil if none found.
func (m *IndicationMessageFormats) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicationMessageFormats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmMetIndicationMessage.(type) {

	case *IndicationMessageFormats_IndicationMessageFormat1:

		if all {
			switch v := interface{}(m.GetIndicationMessageFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndicationMessageFormatsValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndicationMessageFormatsValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationMessageFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndicationMessageFormatsValidationError{
					field:  "IndicationMessageFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndicationMessageFormatsMultiError(errors)
	}

	return nil
}

// IndicationMessageFormatsMultiError is an error wrapping multiple validation
// errors returned by IndicationMessageFormats.ValidateAll() if the designated
// constraints aren't met.
type IndicationMessageFormatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicationMessageFormatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicationMessageFormatsMultiError) AllErrors() []error { return m }

// IndicationMessageFormatsValidationError is the validation error returned by
// IndicationMessageFormats.Validate if the designated constraints aren't met.
type IndicationMessageFormatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicationMessageFormatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndicationMessageFormatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndicationMessageFormatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicationMessageFormatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicationMessageFormatsValidationError) ErrorName() string {
	return "IndicationMessageFormatsValidationError"
}

// Error satisfies the builtin error interface
func (e IndicationMessageFormatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicationMessageFormats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicationMessageFormatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicationMessageFormatsValidationError{}

// Validate checks the field values on E2SmMetIndicationMessageFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetIndicationMessageFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetIndicationMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmMetIndicationMessageFormat1MultiError, or nil if none found.
func (m *E2SmMetIndicationMessageFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetIndicationMessageFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetIndicationMessageFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetIndicationMessageFormat1ValidationError{
				field:  "MeasData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.CellObjId != nil {

		if all {
			switch v := interface{}(m.GetCellObjId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
						field:  "CellObjId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
						field:  "CellObjId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmMetIndicationMessageFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GranulPeriod != nil {

		if all {
			switch v := interface{}(m.GetGranulPeriod()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
						field:  "GranulPeriod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
						field:  "GranulPeriod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmMetIndicationMessageFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MeasInfoList != nil {

		if all {
			switch v := interface{}(m.GetMeasInfoList()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
						field:  "MeasInfoList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmMetIndicationMessageFormat1ValidationError{
						field:  "MeasInfoList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmMetIndicationMessageFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmMetIndicationMessageFormat1MultiError(errors)
	}

	return nil
}

// E2SmMetIndicationMessageFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmMetIndicationMessageFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmMetIndicationMessageFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetIndicationMessageFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetIndicationMessageFormat1MultiError) AllErrors() []error { return m }

// E2SmMetIndicationMessageFormat1ValidationError is the validation error
// returned by E2SmMetIndicationMessageFormat1.Validate if the designated
// constraints aren't met.
type E2SmMetIndicationMessageFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetIndicationMessageFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetIndicationMessageFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetIndicationMessageFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetIndicationMessageFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetIndicationMessageFormat1ValidationError) ErrorName() string {
	return "E2SmMetIndicationMessageFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetIndicationMessageFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetIndicationMessageFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetIndicationMessageFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetIndicationMessageFormat1ValidationError{}

// Validate checks the field values on E2SmMetRanfunctionDescription with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmMetRanfunctionDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmMetRanfunctionDescription with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmMetRanfunctionDescriptionMultiError, or nil if none found.
func (m *E2SmMetRanfunctionDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmMetRanfunctionDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRanFunctionName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmMetRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmMetRanfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRanFunctionName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmMetRanfunctionDescriptionValidationError{
				field:  "RanFunctionName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetRicEventTriggerStyleList()) > 63 {
		err := E2SmMetRanfunctionDescriptionValidationError{
			field:  "RicEventTriggerStyleList",
			reason: "value must contain no more than 63 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicEventTriggerStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmMetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmMetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmMetRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetRicReportStyleList()) > 63 {
		err := E2SmMetRanfunctionDescriptionValidationError{
			field:  "RicReportStyleList",
			reason: "value must contain no more than 63 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicReportStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmMetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmMetRanfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmMetRanfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmMetRanfunctionDescriptionMultiError(errors)
	}

	return nil
}

// E2SmMetRanfunctionDescriptionMultiError is an error wrapping multiple
// validation errors returned by E2SmMetRanfunctionDescription.ValidateAll()
// if the designated constraints aren't met.
type E2SmMetRanfunctionDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmMetRanfunctionDescriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmMetRanfunctionDescriptionMultiError) AllErrors() []error { return m }

// E2SmMetRanfunctionDescriptionValidationError is the validation error
// returned by E2SmMetRanfunctionDescription.Validate if the designated
// constraints aren't met.
type E2SmMetRanfunctionDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmMetRanfunctionDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmMetRanfunctionDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmMetRanfunctionDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmMetRanfunctionDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmMetRanfunctionDescriptionValidationError) ErrorName() string {
	return "E2SmMetRanfunctionDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmMetRanfunctionDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmMetRanfunctionDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmMetRanfunctionDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmMetRanfunctionDescriptionValidationError{}

// Validate checks the field values on RicStyleType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleTypeMultiError, or
// nil if none found.
func (m *RicStyleType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := RicStyleTypeValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicStyleTypeMultiError(errors)
	}

	return nil
}

// RicStyleTypeMultiError is an error wrapping multiple validation errors
// returned by RicStyleType.ValidateAll() if the designated constraints aren't met.
type RicStyleTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleTypeMultiError) AllErrors() []error { return m }

// RicStyleTypeValidationError is the validation error returned by
// RicStyleType.Validate if the designated constraints aren't met.
type RicStyleTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleTypeValidationError) ErrorName() string { return "RicStyleTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleTypeValidationError{}

// Validate checks the field values on RicFormatType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicFormatType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicFormatType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicFormatTypeMultiError, or
// nil if none found.
func (m *RicFormatType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicFormatType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := RicFormatTypeValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicFormatTypeMultiError(errors)
	}

	return nil
}

// RicFormatTypeMultiError is an error wrapping multiple validation errors
// returned by RicFormatType.ValidateAll() if the designated constraints
// aren't met.
type RicFormatTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicFormatTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicFormatTypeMultiError) AllErrors() []error { return m }

// RicFormatTypeValidationError is the validation error returned by
// RicFormatType.Validate if the designated constraints aren't met.
type RicFormatTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicFormatTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicFormatTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicFormatTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicFormatTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicFormatTypeValidationError) ErrorName() string { return "RicFormatTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicFormatTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicFormatType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicFormatTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicFormatTypeValidationError{}

// Validate checks the field values on RicEventTriggerStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicEventTriggerStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicEventTriggerStyleItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicEventTriggerStyleItemMultiError, or nil if none found.
func (m *RicEventTriggerStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicEventTriggerStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicEventTriggerStyleItemMultiError(errors)
	}

	return nil
}

// RicEventTriggerStyleItemMultiError is an error wrapping multiple validation
// errors returned by RicEventTriggerStyleItem.ValidateAll() if the designated
// constraints aren't met.
type RicEventTriggerStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicEventTriggerStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicEventTriggerStyleItemMultiError) AllErrors() []error { return m }

// RicEventTriggerStyleItemValidationError is the validation error returned by
// RicEventTriggerStyleItem.Validate if the designated constraints aren't met.
type RicEventTriggerStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicEventTriggerStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicEventTriggerStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicEventTriggerStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicEventTriggerStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicEventTriggerStyleItemValidationError) ErrorName() string {
	return "RicEventTriggerStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicEventTriggerStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicEventTriggerStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicEventTriggerStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicEventTriggerStyleItemValidationError{}

// Validate checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicReportStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicReportStyleItemMultiError, or nil if none found.
func (m *RicReportStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicReportStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicReportStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicReportStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicActionFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicActionFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicActionFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoActionList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoActionList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "MeasInfoActionList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationHeaderFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationHeaderFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationHeaderFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationMessageFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationMessageFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationMessageFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicReportStyleItemMultiError(errors)
	}

	return nil
}

// RicReportStyleItemMultiError is an error wrapping multiple validation errors
// returned by RicReportStyleItem.ValidateAll() if the designated constraints
// aren't met.
type RicReportStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicReportStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicReportStyleItemMultiError) AllErrors() []error { return m }

// RicReportStyleItemValidationError is the validation error returned by
// RicReportStyleItem.Validate if the designated constraints aren't met.
type RicReportStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicReportStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicReportStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicReportStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicReportStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicReportStyleItemValidationError) ErrorName() string {
	return "RicReportStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicReportStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicReportStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicReportStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicReportStyleItemValidationError{}

// Validate checks the field values on RicStyleName with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleNameMultiError, or
// nil if none found.
func (m *RicStyleName) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := RicStyleNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicStyleNameMultiError(errors)
	}

	return nil
}

// RicStyleNameMultiError is an error wrapping multiple validation errors
// returned by RicStyleName.ValidateAll() if the designated constraints aren't met.
type RicStyleNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleNameMultiError) AllErrors() []error { return m }

// RicStyleNameValidationError is the validation error returned by
// RicStyleName.Validate if the designated constraints aren't met.
type RicStyleNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleNameValidationError) ErrorName() string { return "RicStyleNameValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleNameValidationError{}

// Validate checks the field values on Uetag with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Uetag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uetag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UetagMultiError, or nil if none found.
func (m *Uetag) ValidateAll() error {
	return m.validate(true)
}

func (m *Uetag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := UetagValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UetagMultiError(errors)
	}

	return nil
}

// UetagMultiError is an error wrapping multiple validation errors returned by
// Uetag.ValidateAll() if the designated constraints aren't met.
type UetagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UetagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UetagMultiError) AllErrors() []error { return m }

// UetagValidationError is the validation error returned by Uetag.Validate if
// the designated constraints aren't met.
type UetagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UetagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UetagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UetagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UetagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UetagValidationError) ErrorName() string { return "UetagValidationError" }

// Error satisfies the builtin error interface
func (e UetagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUetag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UetagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UetagValidationError{}

// Validate checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeNameMultiError, or nil if none found.
func (m *MeasurementTypeName) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := MeasurementTypeNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeNameMultiError(errors)
	}

	return nil
}

// MeasurementTypeNameMultiError is an error wrapping multiple validation
// errors returned by MeasurementTypeName.ValidateAll() if the designated
// constraints aren't met.
type MeasurementTypeNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeNameMultiError) AllErrors() []error { return m }

// MeasurementTypeNameValidationError is the validation error returned by
// MeasurementTypeName.Validate if the designated constraints aren't met.
type MeasurementTypeNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeNameValidationError) ErrorName() string {
	return "MeasurementTypeNameValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeNameValidationError{}

// Validate checks the field values on TimeStamp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeStamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeStamp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeStampMultiError, or nil
// if none found.
func (m *TimeStamp) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeStamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 4 {
		err := TimeStampValidationError{
			field:  "Value",
			reason: "value length must be 4 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TimeStampMultiError(errors)
	}

	return nil
}

// TimeStampMultiError is an error wrapping multiple validation errors returned
// by TimeStamp.ValidateAll() if the designated constraints aren't met.
type TimeStampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeStampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeStampMultiError) AllErrors() []error { return m }

// TimeStampValidationError is the validation error returned by
// TimeStamp.Validate if the designated constraints aren't met.
type TimeStampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeStampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeStampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeStampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeStampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeStampValidationError) ErrorName() string { return "TimeStampValidationError" }

// Error satisfies the builtin error interface
func (e TimeStampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeStamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeStampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeStampValidationError{}
