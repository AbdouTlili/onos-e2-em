// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: e2sm_xtdd/v1/e2sm_xtdd.proto

package e2sm_xtdd_go

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TimeStamp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeStamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeStamp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeStampMultiError, or nil
// if none found.
func (m *TimeStamp) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeStamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 4 {
		err := TimeStampValidationError{
			field:  "Value",
			reason: "value length must be 4 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TimeStampMultiError(errors)
	}

	return nil
}

// TimeStampMultiError is an error wrapping multiple validation errors returned
// by TimeStamp.ValidateAll() if the designated constraints aren't met.
type TimeStampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeStampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeStampMultiError) AllErrors() []error { return m }

// TimeStampValidationError is the validation error returned by
// TimeStamp.Validate if the designated constraints aren't met.
type TimeStampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeStampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeStampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeStampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeStampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeStampValidationError) ErrorName() string { return "TimeStampValidationError" }

// Error satisfies the builtin error interface
func (e TimeStampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeStamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeStampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeStampValidationError{}

// Validate checks the field values on CellObjectId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CellObjectId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CellObjectId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CellObjectIdMultiError, or
// nil if none found.
func (m *CellObjectId) ValidateAll() error {
	return m.validate(true)
}

func (m *CellObjectId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := CellObjectIdValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CellObjectIdMultiError(errors)
	}

	return nil
}

// CellObjectIdMultiError is an error wrapping multiple validation errors
// returned by CellObjectId.ValidateAll() if the designated constraints aren't met.
type CellObjectIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CellObjectIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CellObjectIdMultiError) AllErrors() []error { return m }

// CellObjectIdValidationError is the validation error returned by
// CellObjectId.Validate if the designated constraints aren't met.
type CellObjectIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CellObjectIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CellObjectIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CellObjectIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CellObjectIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CellObjectIdValidationError) ErrorName() string { return "CellObjectIdValidationError" }

// Error satisfies the builtin error interface
func (e CellObjectIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCellObjectId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CellObjectIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CellObjectIdValidationError{}

// Validate checks the field values on GranularityPeriod with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GranularityPeriod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GranularityPeriod with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GranularityPeriodMultiError, or nil if none found.
func (m *GranularityPeriod) ValidateAll() error {
	return m.validate(true)
}

func (m *GranularityPeriod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := GranularityPeriodValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GranularityPeriodMultiError(errors)
	}

	return nil
}

// GranularityPeriodMultiError is an error wrapping multiple validation errors
// returned by GranularityPeriod.ValidateAll() if the designated constraints
// aren't met.
type GranularityPeriodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GranularityPeriodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GranularityPeriodMultiError) AllErrors() []error { return m }

// GranularityPeriodValidationError is the validation error returned by
// GranularityPeriod.Validate if the designated constraints aren't met.
type GranularityPeriodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GranularityPeriodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GranularityPeriodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GranularityPeriodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GranularityPeriodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GranularityPeriodValidationError) ErrorName() string {
	return "GranularityPeriodValidationError"
}

// Error satisfies the builtin error interface
func (e GranularityPeriodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGranularityPeriod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GranularityPeriodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GranularityPeriodValidationError{}

// Validate checks the field values on SubscriptionId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubscriptionId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptionIdMultiError,
// or nil if none found.
func (m *SubscriptionId) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := SubscriptionIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SubscriptionIdMultiError(errors)
	}

	return nil
}

// SubscriptionIdMultiError is an error wrapping multiple validation errors
// returned by SubscriptionId.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionIdMultiError) AllErrors() []error { return m }

// SubscriptionIdValidationError is the validation error returned by
// SubscriptionId.Validate if the designated constraints aren't met.
type SubscriptionIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionIdValidationError) ErrorName() string { return "SubscriptionIdValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionIdValidationError{}

// Validate checks the field values on GlobalXtddnodeID with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GlobalXtddnodeID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobalXtddnodeID with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobalXtddnodeIDMultiError, or nil if none found.
func (m *GlobalXtddnodeID) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobalXtddnodeID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 4294967295 {
		err := GlobalXtddnodeIDValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GlobalXtddnodeIDMultiError(errors)
	}

	return nil
}

// GlobalXtddnodeIDMultiError is an error wrapping multiple validation errors
// returned by GlobalXtddnodeID.ValidateAll() if the designated constraints
// aren't met.
type GlobalXtddnodeIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobalXtddnodeIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobalXtddnodeIDMultiError) AllErrors() []error { return m }

// GlobalXtddnodeIDValidationError is the validation error returned by
// GlobalXtddnodeID.Validate if the designated constraints aren't met.
type GlobalXtddnodeIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobalXtddnodeIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobalXtddnodeIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobalXtddnodeIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobalXtddnodeIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobalXtddnodeIDValidationError) ErrorName() string { return "GlobalXtddnodeIDValidationError" }

// Error satisfies the builtin error interface
func (e GlobalXtddnodeIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobalXtddnodeID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobalXtddnodeIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobalXtddnodeIDValidationError{}

// Validate checks the field values on RanfunctionName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RanfunctionName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RanfunctionName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RanfunctionNameMultiError, or nil if none found.
func (m *RanfunctionName) ValidateAll() error {
	return m.validate(true)
}

func (m *RanfunctionName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetRanFunctionShortName()); l < 1 || l > 150 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionShortName",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRanFunctionE2SmOid()); l < 1 || l > 1000 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionE2SmOid",
			reason: "value length must be between 1 and 1000 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetRanFunctionDescription()); l < 1 || l > 150 {
		err := RanfunctionNameValidationError{
			field:  "RanFunctionDescription",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RanfunctionNameMultiError(errors)
	}

	return nil
}

// RanfunctionNameMultiError is an error wrapping multiple validation errors
// returned by RanfunctionName.ValidateAll() if the designated constraints
// aren't met.
type RanfunctionNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RanfunctionNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RanfunctionNameMultiError) AllErrors() []error { return m }

// RanfunctionNameValidationError is the validation error returned by
// RanfunctionName.Validate if the designated constraints aren't met.
type RanfunctionNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RanfunctionNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RanfunctionNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RanfunctionNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RanfunctionNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RanfunctionNameValidationError) ErrorName() string { return "RanfunctionNameValidationError" }

// Error satisfies the builtin error interface
func (e RanfunctionNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRanfunctionName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RanfunctionNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RanfunctionNameValidationError{}

// Validate checks the field values on MaxofUe with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MaxofUe) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MaxofUe with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MaxofUeMultiError, or nil if none found.
func (m *MaxofUe) ValidateAll() error {
	return m.validate(true)
}

func (m *MaxofUe) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetValue() != 65535 {
		err := MaxofUeValidationError{
			field:  "Value",
			reason: "value must equal 65535",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MaxofUeMultiError(errors)
	}

	return nil
}

// MaxofUeMultiError is an error wrapping multiple validation errors returned
// by MaxofUe.ValidateAll() if the designated constraints aren't met.
type MaxofUeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MaxofUeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MaxofUeMultiError) AllErrors() []error { return m }

// MaxofUeValidationError is the validation error returned by MaxofUe.Validate
// if the designated constraints aren't met.
type MaxofUeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MaxofUeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MaxofUeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MaxofUeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MaxofUeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MaxofUeValidationError) ErrorName() string { return "MaxofUeValidationError" }

// Error satisfies the builtin error interface
func (e MaxofUeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMaxofUe.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MaxofUeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MaxofUeValidationError{}

// Validate checks the field values on Ueid with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Ueid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ueid with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UeidMultiError, or nil if none found.
func (m *Ueid) ValidateAll() error {
	return m.validate(true)
}

func (m *Ueid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 4294967295 {
		err := UeidValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 4294967295]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UeidMultiError(errors)
	}

	return nil
}

// UeidMultiError is an error wrapping multiple validation errors returned by
// Ueid.ValidateAll() if the designated constraints aren't met.
type UeidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeidMultiError) AllErrors() []error { return m }

// UeidValidationError is the validation error returned by Ueid.Validate if the
// designated constraints aren't met.
type UeidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeidValidationError) ErrorName() string { return "UeidValidationError" }

// Error satisfies the builtin error interface
func (e UeidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeidValidationError{}

// Validate checks the field values on Uetag with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Uetag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uetag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UetagMultiError, or nil if none found.
func (m *Uetag) ValidateAll() error {
	return m.validate(true)
}

func (m *Uetag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := UetagValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UetagMultiError(errors)
	}

	return nil
}

// UetagMultiError is an error wrapping multiple validation errors returned by
// Uetag.ValidateAll() if the designated constraints aren't met.
type UetagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UetagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UetagMultiError) AllErrors() []error { return m }

// UetagValidationError is the validation error returned by Uetag.Validate if
// the designated constraints aren't met.
type UetagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UetagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UetagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UetagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UetagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UetagValidationError) ErrorName() string { return "UetagValidationError" }

// Error satisfies the builtin error interface
func (e UetagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUetag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UetagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UetagValidationError{}

// Validate checks the field values on Ueitem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Ueitem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ueitem with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UeitemMultiError, or nil if none found.
func (m *Ueitem) ValidateAll() error {
	return m.validate(true)
}

func (m *Ueitem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UeitemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UeitemValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UeitemValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.UeTag != nil {

		if all {
			switch v := interface{}(m.GetUeTag()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UeitemValidationError{
						field:  "UeTag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UeitemValidationError{
						field:  "UeTag",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUeTag()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UeitemValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UeitemMultiError(errors)
	}

	return nil
}

// UeitemMultiError is an error wrapping multiple validation errors returned by
// Ueitem.ValidateAll() if the designated constraints aren't met.
type UeitemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UeitemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UeitemMultiError) AllErrors() []error { return m }

// UeitemValidationError is the validation error returned by Ueitem.Validate if
// the designated constraints aren't met.
type UeitemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UeitemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UeitemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UeitemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UeitemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UeitemValidationError) ErrorName() string { return "UeitemValidationError" }

// Error satisfies the builtin error interface
func (e UeitemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUeitem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UeitemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UeitemValidationError{}

// Validate checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoListMultiError, or nil if none found.
func (m *MeasurementInfoList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoListMultiError(errors)
	}

	return nil
}

// MeasurementInfoListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoList.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoListMultiError) AllErrors() []error { return m }

// MeasurementInfoListValidationError is the validation error returned by
// MeasurementInfoList.Validate if the designated constraints aren't met.
type MeasurementInfoListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoListValidationError) ErrorName() string {
	return "MeasurementInfoListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoListValidationError{}

// Validate checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoItemMultiError, or nil if none found.
func (m *MeasurementInfoItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := MeasurementInfoItemValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementInfoItemMultiError(errors)
	}

	return nil
}

// MeasurementInfoItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementInfoItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoItemMultiError) AllErrors() []error { return m }

// MeasurementInfoItemValidationError is the validation error returned by
// MeasurementInfoItem.Validate if the designated constraints aren't met.
type MeasurementInfoItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoItemValidationError) ErrorName() string {
	return "MeasurementInfoItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoItemValidationError{}

// Validate checks the field values on MeasurementData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementDataMultiError, or nil if none found.
func (m *MeasurementData) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementDataValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementDataValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementDataMultiError(errors)
	}

	return nil
}

// MeasurementDataMultiError is an error wrapping multiple validation errors
// returned by MeasurementData.ValidateAll() if the designated constraints
// aren't met.
type MeasurementDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementDataMultiError) AllErrors() []error { return m }

// MeasurementDataValidationError is the validation error returned by
// MeasurementData.Validate if the designated constraints aren't met.
type MeasurementDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementDataValidationError) ErrorName() string { return "MeasurementDataValidationError" }

// Error satisfies the builtin error interface
func (e MeasurementDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementDataValidationError{}

// Validate checks the field values on MeasurementRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordMultiError, or nil if none found.
func (m *MeasurementRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementRecordValidationError{
				field:  "UeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUeTag()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "UeTag",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUeTag()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementRecordValidationError{
				field:  "UeTag",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasRecordItemList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "MeasRecordItemList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementRecordValidationError{
					field:  "MeasRecordItemList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasRecordItemList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementRecordValidationError{
				field:  "MeasRecordItemList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MeasurementRecordMultiError(errors)
	}

	return nil
}

// MeasurementRecordMultiError is an error wrapping multiple validation errors
// returned by MeasurementRecord.ValidateAll() if the designated constraints
// aren't met.
type MeasurementRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordMultiError) AllErrors() []error { return m }

// MeasurementRecordValidationError is the validation error returned by
// MeasurementRecord.Validate if the designated constraints aren't met.
type MeasurementRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordValidationError) ErrorName() string {
	return "MeasurementRecordValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordValidationError{}

// Validate checks the field values on MeasurementRecordItemList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecordItemList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecordItemList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordItemListMultiError, or nil if none found.
func (m *MeasurementRecordItemList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecordItemList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementRecordItemListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementRecordItemListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementRecordItemListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementRecordItemListMultiError(errors)
	}

	return nil
}

// MeasurementRecordItemListMultiError is an error wrapping multiple validation
// errors returned by MeasurementRecordItemList.ValidateAll() if the
// designated constraints aren't met.
type MeasurementRecordItemListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordItemListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordItemListMultiError) AllErrors() []error { return m }

// MeasurementRecordItemListValidationError is the validation error returned by
// MeasurementRecordItemList.Validate if the designated constraints aren't met.
type MeasurementRecordItemListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordItemListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordItemListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordItemListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordItemListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordItemListValidationError) ErrorName() string {
	return "MeasurementRecordItemListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordItemListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecordItemList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordItemListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordItemListValidationError{}

// Validate checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementRecordItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementRecordItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementRecordItemMultiError, or nil if none found.
func (m *MeasurementRecordItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementRecordItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := MeasurementRecordItemValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementRecordItemMultiError(errors)
	}

	return nil
}

// MeasurementRecordItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementRecordItem.ValidateAll() if the designated
// constraints aren't met.
type MeasurementRecordItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementRecordItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementRecordItemMultiError) AllErrors() []error { return m }

// MeasurementRecordItemValidationError is the validation error returned by
// MeasurementRecordItem.Validate if the designated constraints aren't met.
type MeasurementRecordItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementRecordItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementRecordItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementRecordItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementRecordItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementRecordItemValidationError) ErrorName() string {
	return "MeasurementRecordItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementRecordItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementRecordItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementRecordItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementRecordItemValidationError{}

// Validate checks the field values on MeasurementInfoActionList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionListMultiError, or nil if none found.
func (m *MeasurementInfoActionList) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoActionListValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoActionListValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoActionListMultiError(errors)
	}

	return nil
}

// MeasurementInfoActionListMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionList.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionListMultiError) AllErrors() []error { return m }

// MeasurementInfoActionListValidationError is the validation error returned by
// MeasurementInfoActionList.Validate if the designated constraints aren't met.
type MeasurementInfoActionListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionListValidationError) ErrorName() string {
	return "MeasurementInfoActionListValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionListValidationError{}

// Validate checks the field values on MeasurementInfoActionItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementInfoActionItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementInfoActionItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementInfoActionItemMultiError, or nil if none found.
func (m *MeasurementInfoActionItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementInfoActionItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeasName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MeasurementInfoActionItemValidationError{
					field:  "MeasName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MeasurementInfoActionItemValidationError{
				field:  "MeasName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.MeasId != nil {

		if all {
			switch v := interface{}(m.GetMeasId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MeasurementInfoActionItemValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MeasurementInfoActionItemValidationError{
						field:  "MeasId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MeasurementInfoActionItemValidationError{
					field:  "MeasId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MeasurementInfoActionItemMultiError(errors)
	}

	return nil
}

// MeasurementInfoActionItemMultiError is an error wrapping multiple validation
// errors returned by MeasurementInfoActionItem.ValidateAll() if the
// designated constraints aren't met.
type MeasurementInfoActionItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementInfoActionItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementInfoActionItemMultiError) AllErrors() []error { return m }

// MeasurementInfoActionItemValidationError is the validation error returned by
// MeasurementInfoActionItem.Validate if the designated constraints aren't met.
type MeasurementInfoActionItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementInfoActionItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementInfoActionItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementInfoActionItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementInfoActionItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementInfoActionItemValidationError) ErrorName() string {
	return "MeasurementInfoActionItemValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementInfoActionItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementInfoActionItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementInfoActionItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementInfoActionItemValidationError{}

// Validate checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeNameMultiError, or nil if none found.
func (m *MeasurementTypeName) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := MeasurementTypeNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeNameMultiError(errors)
	}

	return nil
}

// MeasurementTypeNameMultiError is an error wrapping multiple validation
// errors returned by MeasurementTypeName.ValidateAll() if the designated
// constraints aren't met.
type MeasurementTypeNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeNameMultiError) AllErrors() []error { return m }

// MeasurementTypeNameValidationError is the validation error returned by
// MeasurementTypeName.Validate if the designated constraints aren't met.
type MeasurementTypeNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeNameValidationError) ErrorName() string {
	return "MeasurementTypeNameValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeNameValidationError{}

// Validate checks the field values on MeasurementTypeId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MeasurementTypeId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MeasurementTypeId with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MeasurementTypeIdMultiError, or nil if none found.
func (m *MeasurementTypeId) ValidateAll() error {
	return m.validate(true)
}

func (m *MeasurementTypeId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 1 || val > 65535 {
		err := MeasurementTypeIdValidationError{
			field:  "Value",
			reason: "value must be inside range [1, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MeasurementTypeIdMultiError(errors)
	}

	return nil
}

// MeasurementTypeIdMultiError is an error wrapping multiple validation errors
// returned by MeasurementTypeId.ValidateAll() if the designated constraints
// aren't met.
type MeasurementTypeIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MeasurementTypeIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MeasurementTypeIdMultiError) AllErrors() []error { return m }

// MeasurementTypeIdValidationError is the validation error returned by
// MeasurementTypeId.Validate if the designated constraints aren't met.
type MeasurementTypeIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MeasurementTypeIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MeasurementTypeIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MeasurementTypeIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MeasurementTypeIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MeasurementTypeIdValidationError) ErrorName() string {
	return "MeasurementTypeIdValidationError"
}

// Error satisfies the builtin error interface
func (e MeasurementTypeIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMeasurementTypeId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MeasurementTypeIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MeasurementTypeIdValidationError{}

// Validate checks the field values on
// EventDefinitionformatsE2SmXTddEventTriggerDefinition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EventDefinitionformatsE2SmXTddEventTriggerDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// EventDefinitionformatsE2SmXTddEventTriggerDefinition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// EventDefinitionformatsE2SmXTddEventTriggerDefinitionMultiError, or nil if
// none found.
func (m *EventDefinitionformatsE2SmXTddEventTriggerDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *EventDefinitionformatsE2SmXTddEventTriggerDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.EventDefinitionFormatsE2SmXtddEventTriggerDefinition.(type) {

	case *EventDefinitionformatsE2SmXTddEventTriggerDefinition_EventDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetEventDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError{
						field:  "EventDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEventDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EventDefinitionformatsE2SmXTddEventTriggerDefinitionMultiError(errors)
	}

	return nil
}

// EventDefinitionformatsE2SmXTddEventTriggerDefinitionMultiError is an error
// wrapping multiple validation errors returned by
// EventDefinitionformatsE2SmXTddEventTriggerDefinition.ValidateAll() if the
// designated constraints aren't met.
type EventDefinitionformatsE2SmXTddEventTriggerDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventDefinitionformatsE2SmXTddEventTriggerDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventDefinitionformatsE2SmXTddEventTriggerDefinitionMultiError) AllErrors() []error { return m }

// EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError is the
// validation error returned by
// EventDefinitionformatsE2SmXTddEventTriggerDefinition.Validate if the
// designated constraints aren't met.
type EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError) ErrorName() string {
	return "EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventDefinitionformatsE2SmXTddEventTriggerDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventDefinitionformatsE2SmXTddEventTriggerDefinitionValidationError{}

// Validate checks the field values on E2SmXTddEventTriggerDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddEventTriggerDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddEventTriggerDefinition with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmXTddEventTriggerDefinitionMultiError, or nil if none found.
func (m *E2SmXTddEventTriggerDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddEventTriggerDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDefinitionFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddEventTriggerDefinitionValidationError{
					field:  "EventDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDefinitionFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddEventTriggerDefinitionValidationError{
				field:  "EventDefinitionFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmXTddEventTriggerDefinitionMultiError(errors)
	}

	return nil
}

// E2SmXTddEventTriggerDefinitionMultiError is an error wrapping multiple
// validation errors returned by E2SmXTddEventTriggerDefinition.ValidateAll()
// if the designated constraints aren't met.
type E2SmXTddEventTriggerDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddEventTriggerDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddEventTriggerDefinitionMultiError) AllErrors() []error { return m }

// E2SmXTddEventTriggerDefinitionValidationError is the validation error
// returned by E2SmXTddEventTriggerDefinition.Validate if the designated
// constraints aren't met.
type E2SmXTddEventTriggerDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddEventTriggerDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddEventTriggerDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddEventTriggerDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddEventTriggerDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddEventTriggerDefinitionValidationError) ErrorName() string {
	return "E2SmXTddEventTriggerDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddEventTriggerDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddEventTriggerDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddEventTriggerDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddEventTriggerDefinitionValidationError{}

// Validate checks the field values on E2SmXTddEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *E2SmXTddEventTriggerDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddEventTriggerDefinitionFormat1
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// E2SmXTddEventTriggerDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmXTddEventTriggerDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddEventTriggerDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReportingPeriod

	if len(errors) > 0 {
		return E2SmXTddEventTriggerDefinitionFormat1MultiError(errors)
	}

	return nil
}

// E2SmXTddEventTriggerDefinitionFormat1MultiError is an error wrapping
// multiple validation errors returned by
// E2SmXTddEventTriggerDefinitionFormat1.ValidateAll() if the designated
// constraints aren't met.
type E2SmXTddEventTriggerDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddEventTriggerDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddEventTriggerDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmXTddEventTriggerDefinitionFormat1ValidationError is the validation error
// returned by E2SmXTddEventTriggerDefinitionFormat1.Validate if the
// designated constraints aren't met.
type E2SmXTddEventTriggerDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddEventTriggerDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddEventTriggerDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddEventTriggerDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddEventTriggerDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddEventTriggerDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmXTddEventTriggerDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddEventTriggerDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddEventTriggerDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddEventTriggerDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddEventTriggerDefinitionFormat1ValidationError{}

// Validate checks the field values on
// ActionDefinitionformatsE2SmXTddActionDefinition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionDefinitionformatsE2SmXTddActionDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ActionDefinitionformatsE2SmXTddActionDefinition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ActionDefinitionformatsE2SmXTddActionDefinitionMultiError, or nil if none found.
func (m *ActionDefinitionformatsE2SmXTddActionDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionDefinitionformatsE2SmXTddActionDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.ActionDefinitionFormatsE2SmXtddActionDefinition.(type) {

	case *ActionDefinitionformatsE2SmXTddActionDefinition_ActionDefinitionFormat1:

		if all {
			switch v := interface{}(m.GetActionDefinitionFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDefinitionformatsE2SmXTddActionDefinitionValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDefinitionformatsE2SmXTddActionDefinitionValidationError{
						field:  "ActionDefinitionFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionDefinitionFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDefinitionformatsE2SmXTddActionDefinitionValidationError{
					field:  "ActionDefinitionFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionDefinitionformatsE2SmXTddActionDefinitionMultiError(errors)
	}

	return nil
}

// ActionDefinitionformatsE2SmXTddActionDefinitionMultiError is an error
// wrapping multiple validation errors returned by
// ActionDefinitionformatsE2SmXTddActionDefinition.ValidateAll() if the
// designated constraints aren't met.
type ActionDefinitionformatsE2SmXTddActionDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionDefinitionformatsE2SmXTddActionDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionDefinitionformatsE2SmXTddActionDefinitionMultiError) AllErrors() []error { return m }

// ActionDefinitionformatsE2SmXTddActionDefinitionValidationError is the
// validation error returned by
// ActionDefinitionformatsE2SmXTddActionDefinition.Validate if the designated
// constraints aren't met.
type ActionDefinitionformatsE2SmXTddActionDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionDefinitionformatsE2SmXTddActionDefinitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ActionDefinitionformatsE2SmXTddActionDefinitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ActionDefinitionformatsE2SmXTddActionDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionDefinitionformatsE2SmXTddActionDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionDefinitionformatsE2SmXTddActionDefinitionValidationError) ErrorName() string {
	return "ActionDefinitionformatsE2SmXTddActionDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e ActionDefinitionformatsE2SmXTddActionDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionDefinitionformatsE2SmXTddActionDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionDefinitionformatsE2SmXTddActionDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionDefinitionformatsE2SmXTddActionDefinitionValidationError{}

// Validate checks the field values on E2SmXTddActionDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddActionDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddActionDefinition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmXTddActionDefinitionMultiError, or nil if none found.
func (m *E2SmXTddActionDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddActionDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionValidationError{
					field:  "RicStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddActionDefinitionValidationError{
				field:  "RicStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActionDefinitionFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionValidationError{
					field:  "ActionDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionValidationError{
					field:  "ActionDefinitionFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionDefinitionFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddActionDefinitionValidationError{
				field:  "ActionDefinitionFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmXTddActionDefinitionMultiError(errors)
	}

	return nil
}

// E2SmXTddActionDefinitionMultiError is an error wrapping multiple validation
// errors returned by E2SmXTddActionDefinition.ValidateAll() if the designated
// constraints aren't met.
type E2SmXTddActionDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddActionDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddActionDefinitionMultiError) AllErrors() []error { return m }

// E2SmXTddActionDefinitionValidationError is the validation error returned by
// E2SmXTddActionDefinition.Validate if the designated constraints aren't met.
type E2SmXTddActionDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddActionDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddActionDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddActionDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddActionDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddActionDefinitionValidationError) ErrorName() string {
	return "E2SmXTddActionDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddActionDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddActionDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddActionDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddActionDefinitionValidationError{}

// Validate checks the field values on E2SmXTddActionDefinitionFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddActionDefinitionFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddActionDefinitionFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmXTddActionDefinitionFormat1MultiError, or nil if none found.
func (m *E2SmXTddActionDefinitionFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddActionDefinitionFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCellObjId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddActionDefinitionFormat1ValidationError{
				field:  "CellObjId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddActionDefinitionFormat1ValidationError{
				field:  "MeasInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGranulPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddActionDefinitionFormat1ValidationError{
				field:  "GranulPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddActionDefinitionFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddActionDefinitionFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmXTddActionDefinitionFormat1MultiError(errors)
	}

	return nil
}

// E2SmXTddActionDefinitionFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmXTddActionDefinitionFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmXTddActionDefinitionFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddActionDefinitionFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddActionDefinitionFormat1MultiError) AllErrors() []error { return m }

// E2SmXTddActionDefinitionFormat1ValidationError is the validation error
// returned by E2SmXTddActionDefinitionFormat1.Validate if the designated
// constraints aren't met.
type E2SmXTddActionDefinitionFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddActionDefinitionFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddActionDefinitionFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddActionDefinitionFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddActionDefinitionFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddActionDefinitionFormat1ValidationError) ErrorName() string {
	return "E2SmXTddActionDefinitionFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddActionDefinitionFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddActionDefinitionFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddActionDefinitionFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddActionDefinitionFormat1ValidationError{}

// Validate checks the field values on
// IndicationHeaderformatsE2SmXTddIndicationHeader with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IndicationHeaderformatsE2SmXTddIndicationHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// IndicationHeaderformatsE2SmXTddIndicationHeader with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// IndicationHeaderformatsE2SmXTddIndicationHeaderMultiError, or nil if none found.
func (m *IndicationHeaderformatsE2SmXTddIndicationHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicationHeaderformatsE2SmXTddIndicationHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.IndicationHeaderFormatsE2SmXtddIndicationHeader.(type) {

	case *IndicationHeaderformatsE2SmXTddIndicationHeader_IndicationHeaderFormat1:

		if all {
			switch v := interface{}(m.GetIndicationHeaderFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError{
						field:  "IndicationHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationHeaderFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError{
					field:  "IndicationHeaderFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndicationHeaderformatsE2SmXTddIndicationHeaderMultiError(errors)
	}

	return nil
}

// IndicationHeaderformatsE2SmXTddIndicationHeaderMultiError is an error
// wrapping multiple validation errors returned by
// IndicationHeaderformatsE2SmXTddIndicationHeader.ValidateAll() if the
// designated constraints aren't met.
type IndicationHeaderformatsE2SmXTddIndicationHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicationHeaderformatsE2SmXTddIndicationHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicationHeaderformatsE2SmXTddIndicationHeaderMultiError) AllErrors() []error { return m }

// IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError is the
// validation error returned by
// IndicationHeaderformatsE2SmXTddIndicationHeader.Validate if the designated
// constraints aren't met.
type IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError) ErrorName() string {
	return "IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicationHeaderformatsE2SmXTddIndicationHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicationHeaderformatsE2SmXTddIndicationHeaderValidationError{}

// Validate checks the field values on E2SmXTddIndicationHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddIndicationHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddIndicationHeader with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmXTddIndicationHeaderMultiError, or nil if none found.
func (m *E2SmXTddIndicationHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddIndicationHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIndicationHeaderFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddIndicationHeaderValidationError{
					field:  "IndicationHeaderFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddIndicationHeaderValidationError{
					field:  "IndicationHeaderFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndicationHeaderFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddIndicationHeaderValidationError{
				field:  "IndicationHeaderFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmXTddIndicationHeaderMultiError(errors)
	}

	return nil
}

// E2SmXTddIndicationHeaderMultiError is an error wrapping multiple validation
// errors returned by E2SmXTddIndicationHeader.ValidateAll() if the designated
// constraints aren't met.
type E2SmXTddIndicationHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddIndicationHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddIndicationHeaderMultiError) AllErrors() []error { return m }

// E2SmXTddIndicationHeaderValidationError is the validation error returned by
// E2SmXTddIndicationHeader.Validate if the designated constraints aren't met.
type E2SmXTddIndicationHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddIndicationHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddIndicationHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddIndicationHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddIndicationHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddIndicationHeaderValidationError) ErrorName() string {
	return "E2SmXTddIndicationHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddIndicationHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddIndicationHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddIndicationHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddIndicationHeaderValidationError{}

// Validate checks the field values on E2SmXTddIndicationHeaderFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddIndicationHeaderFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddIndicationHeaderFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmXTddIndicationHeaderFormat1MultiError, or nil if none found.
func (m *E2SmXTddIndicationHeaderFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddIndicationHeaderFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetColletStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddIndicationHeaderFormat1ValidationError{
					field:  "ColletStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetColletStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddIndicationHeaderFormat1ValidationError{
				field:  "ColletStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddIndicationHeaderFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddIndicationHeaderFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddIndicationHeaderFormat1ValidationError{
				field:  "MeasInfoList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.FileFormatversion != nil {

		if l := utf8.RuneCountInString(m.GetFileFormatversion()); l < 0 || l > 15 {
			err := E2SmXTddIndicationHeaderFormat1ValidationError{
				field:  "FileFormatversion",
				reason: "value length must be between 0 and 15 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.SenderName != nil {

		if l := utf8.RuneCountInString(m.GetSenderName()); l < 0 || l > 400 {
			err := E2SmXTddIndicationHeaderFormat1ValidationError{
				field:  "SenderName",
				reason: "value length must be between 0 and 400 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.XtddNodeId != nil {

		if all {
			switch v := interface{}(m.GetXtddNodeId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddIndicationHeaderFormat1ValidationError{
						field:  "XtddNodeId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddIndicationHeaderFormat1ValidationError{
						field:  "XtddNodeId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetXtddNodeId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddIndicationHeaderFormat1ValidationError{
					field:  "XtddNodeId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmXTddIndicationHeaderFormat1MultiError(errors)
	}

	return nil
}

// E2SmXTddIndicationHeaderFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmXTddIndicationHeaderFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmXTddIndicationHeaderFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddIndicationHeaderFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddIndicationHeaderFormat1MultiError) AllErrors() []error { return m }

// E2SmXTddIndicationHeaderFormat1ValidationError is the validation error
// returned by E2SmXTddIndicationHeaderFormat1.Validate if the designated
// constraints aren't met.
type E2SmXTddIndicationHeaderFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddIndicationHeaderFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddIndicationHeaderFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddIndicationHeaderFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddIndicationHeaderFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddIndicationHeaderFormat1ValidationError) ErrorName() string {
	return "E2SmXTddIndicationHeaderFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddIndicationHeaderFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddIndicationHeaderFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddIndicationHeaderFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddIndicationHeaderFormat1ValidationError{}

// Validate checks the field values on
// IndicationMessageformatsE2SmXTddIndicationMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IndicationMessageformatsE2SmXTddIndicationMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// IndicationMessageformatsE2SmXTddIndicationMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// IndicationMessageformatsE2SmXTddIndicationMessageMultiError, or nil if none found.
func (m *IndicationMessageformatsE2SmXTddIndicationMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicationMessageformatsE2SmXTddIndicationMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.IndicationMessageFormatsE2SmXtddIndicationMessage.(type) {

	case *IndicationMessageformatsE2SmXTddIndicationMessage_IndicationMessageFormat1:

		if all {
			switch v := interface{}(m.GetIndicationMessageFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndicationMessageformatsE2SmXTddIndicationMessageValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndicationMessageformatsE2SmXTddIndicationMessageValidationError{
						field:  "IndicationMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIndicationMessageFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndicationMessageformatsE2SmXTddIndicationMessageValidationError{
					field:  "IndicationMessageFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndicationMessageformatsE2SmXTddIndicationMessageMultiError(errors)
	}

	return nil
}

// IndicationMessageformatsE2SmXTddIndicationMessageMultiError is an error
// wrapping multiple validation errors returned by
// IndicationMessageformatsE2SmXTddIndicationMessage.ValidateAll() if the
// designated constraints aren't met.
type IndicationMessageformatsE2SmXTddIndicationMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicationMessageformatsE2SmXTddIndicationMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicationMessageformatsE2SmXTddIndicationMessageMultiError) AllErrors() []error { return m }

// IndicationMessageformatsE2SmXTddIndicationMessageValidationError is the
// validation error returned by
// IndicationMessageformatsE2SmXTddIndicationMessage.Validate if the
// designated constraints aren't met.
type IndicationMessageformatsE2SmXTddIndicationMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicationMessageformatsE2SmXTddIndicationMessageValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e IndicationMessageformatsE2SmXTddIndicationMessageValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e IndicationMessageformatsE2SmXTddIndicationMessageValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e IndicationMessageformatsE2SmXTddIndicationMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicationMessageformatsE2SmXTddIndicationMessageValidationError) ErrorName() string {
	return "IndicationMessageformatsE2SmXTddIndicationMessageValidationError"
}

// Error satisfies the builtin error interface
func (e IndicationMessageformatsE2SmXTddIndicationMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicationMessageformatsE2SmXTddIndicationMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicationMessageformatsE2SmXTddIndicationMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicationMessageformatsE2SmXTddIndicationMessageValidationError{}

// Validate checks the field values on E2SmXTddIndicationMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddIndicationMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddIndicationMessage with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmXTddIndicationMessageMultiError, or nil if none found.
func (m *E2SmXTddIndicationMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddIndicationMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIndicationMessageFormats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddIndicationMessageValidationError{
					field:  "IndicationMessageFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddIndicationMessageValidationError{
					field:  "IndicationMessageFormats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndicationMessageFormats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddIndicationMessageValidationError{
				field:  "IndicationMessageFormats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmXTddIndicationMessageMultiError(errors)
	}

	return nil
}

// E2SmXTddIndicationMessageMultiError is an error wrapping multiple validation
// errors returned by E2SmXTddIndicationMessage.ValidateAll() if the
// designated constraints aren't met.
type E2SmXTddIndicationMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddIndicationMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddIndicationMessageMultiError) AllErrors() []error { return m }

// E2SmXTddIndicationMessageValidationError is the validation error returned by
// E2SmXTddIndicationMessage.Validate if the designated constraints aren't met.
type E2SmXTddIndicationMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddIndicationMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddIndicationMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddIndicationMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddIndicationMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddIndicationMessageValidationError) ErrorName() string {
	return "E2SmXTddIndicationMessageValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddIndicationMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddIndicationMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddIndicationMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddIndicationMessageValidationError{}

// Validate checks the field values on E2SmXTddIndicationMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *E2SmXTddIndicationMessageFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddIndicationMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmXTddIndicationMessageFormat1MultiError, or nil if none found.
func (m *E2SmXTddIndicationMessageFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddIndicationMessageFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubscriptId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
					field:  "SubscriptId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscriptId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddIndicationMessageFormat1ValidationError{
				field:  "SubscriptId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
					field:  "MeasData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddIndicationMessageFormat1ValidationError{
				field:  "MeasData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.CellObjId != nil {

		if all {
			switch v := interface{}(m.GetCellObjId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
						field:  "CellObjId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
						field:  "CellObjId",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCellObjId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddIndicationMessageFormat1ValidationError{
					field:  "CellObjId",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GranulPeriod != nil {

		if all {
			switch v := interface{}(m.GetGranulPeriod()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
						field:  "GranulPeriod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
						field:  "GranulPeriod",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGranulPeriod()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddIndicationMessageFormat1ValidationError{
					field:  "GranulPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MeasInfoList != nil {

		if all {
			switch v := interface{}(m.GetMeasInfoList()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
						field:  "MeasInfoList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddIndicationMessageFormat1ValidationError{
						field:  "MeasInfoList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMeasInfoList()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddIndicationMessageFormat1ValidationError{
					field:  "MeasInfoList",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmXTddIndicationMessageFormat1MultiError(errors)
	}

	return nil
}

// E2SmXTddIndicationMessageFormat1MultiError is an error wrapping multiple
// validation errors returned by
// E2SmXTddIndicationMessageFormat1.ValidateAll() if the designated
// constraints aren't met.
type E2SmXTddIndicationMessageFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddIndicationMessageFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddIndicationMessageFormat1MultiError) AllErrors() []error { return m }

// E2SmXTddIndicationMessageFormat1ValidationError is the validation error
// returned by E2SmXTddIndicationMessageFormat1.Validate if the designated
// constraints aren't met.
type E2SmXTddIndicationMessageFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddIndicationMessageFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddIndicationMessageFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddIndicationMessageFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddIndicationMessageFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddIndicationMessageFormat1ValidationError) ErrorName() string {
	return "E2SmXTddIndicationMessageFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddIndicationMessageFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddIndicationMessageFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddIndicationMessageFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddIndicationMessageFormat1ValidationError{}

// Validate checks the field values on E2SmXTddRAnfunctionDescription with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddRAnfunctionDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddRAnfunctionDescription with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmXTddRAnfunctionDescriptionMultiError, or nil if none found.
func (m *E2SmXTddRAnfunctionDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddRAnfunctionDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRanFunctionName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddRAnfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddRAnfunctionDescriptionValidationError{
					field:  "RanFunctionName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRanFunctionName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddRAnfunctionDescriptionValidationError{
				field:  "RanFunctionName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetRicEventTriggerStyleList()); l < 1 || l > 255 {
		err := E2SmXTddRAnfunctionDescriptionValidationError{
			field:  "RicEventTriggerStyleList",
			reason: "value must contain between 1 and 255 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicEventTriggerStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddRAnfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddRAnfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddRAnfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicEventTriggerStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if l := len(m.GetRicReportStyleList()); l < 1 || l > 255 {
		err := E2SmXTddRAnfunctionDescriptionValidationError{
			field:  "RicReportStyleList",
			reason: "value must contain between 1 and 255 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRicReportStyleList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddRAnfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddRAnfunctionDescriptionValidationError{
						field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddRAnfunctionDescriptionValidationError{
					field:  fmt.Sprintf("RicReportStyleList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmXTddRAnfunctionDescriptionMultiError(errors)
	}

	return nil
}

// E2SmXTddRAnfunctionDescriptionMultiError is an error wrapping multiple
// validation errors returned by E2SmXTddRAnfunctionDescription.ValidateAll()
// if the designated constraints aren't met.
type E2SmXTddRAnfunctionDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddRAnfunctionDescriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddRAnfunctionDescriptionMultiError) AllErrors() []error { return m }

// E2SmXTddRAnfunctionDescriptionValidationError is the validation error
// returned by E2SmXTddRAnfunctionDescription.Validate if the designated
// constraints aren't met.
type E2SmXTddRAnfunctionDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddRAnfunctionDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddRAnfunctionDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddRAnfunctionDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddRAnfunctionDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddRAnfunctionDescriptionValidationError) ErrorName() string {
	return "E2SmXTddRAnfunctionDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddRAnfunctionDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddRAnfunctionDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddRAnfunctionDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddRAnfunctionDescriptionValidationError{}

// Validate checks the field values on RicStyleType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleTypeMultiError, or
// nil if none found.
func (m *RicStyleType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := RicStyleTypeValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicStyleTypeMultiError(errors)
	}

	return nil
}

// RicStyleTypeMultiError is an error wrapping multiple validation errors
// returned by RicStyleType.ValidateAll() if the designated constraints aren't met.
type RicStyleTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleTypeMultiError) AllErrors() []error { return m }

// RicStyleTypeValidationError is the validation error returned by
// RicStyleType.Validate if the designated constraints aren't met.
type RicStyleTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleTypeValidationError) ErrorName() string { return "RicStyleTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleTypeValidationError{}

// Validate checks the field values on RicStyleName with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicStyleName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicStyleName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicStyleNameMultiError, or
// nil if none found.
func (m *RicStyleName) ValidateAll() error {
	return m.validate(true)
}

func (m *RicStyleName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := RicStyleNameValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicStyleNameMultiError(errors)
	}

	return nil
}

// RicStyleNameMultiError is an error wrapping multiple validation errors
// returned by RicStyleName.ValidateAll() if the designated constraints aren't met.
type RicStyleNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicStyleNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicStyleNameMultiError) AllErrors() []error { return m }

// RicStyleNameValidationError is the validation error returned by
// RicStyleName.Validate if the designated constraints aren't met.
type RicStyleNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicStyleNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicStyleNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicStyleNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicStyleNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicStyleNameValidationError) ErrorName() string { return "RicStyleNameValidationError" }

// Error satisfies the builtin error interface
func (e RicStyleNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicStyleName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicStyleNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicStyleNameValidationError{}

// Validate checks the field values on RicFormatType with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RicFormatType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicFormatType with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RicFormatTypeMultiError, or
// nil if none found.
func (m *RicFormatType) ValidateAll() error {
	return m.validate(true)
}

func (m *RicFormatType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetValue(); val < 0 || val > 255 {
		err := RicFormatTypeValidationError{
			field:  "Value",
			reason: "value must be inside range [0, 255]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RicFormatTypeMultiError(errors)
	}

	return nil
}

// RicFormatTypeMultiError is an error wrapping multiple validation errors
// returned by RicFormatType.ValidateAll() if the designated constraints
// aren't met.
type RicFormatTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicFormatTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicFormatTypeMultiError) AllErrors() []error { return m }

// RicFormatTypeValidationError is the validation error returned by
// RicFormatType.Validate if the designated constraints aren't met.
type RicFormatTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicFormatTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicFormatTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicFormatTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicFormatTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicFormatTypeValidationError) ErrorName() string { return "RicFormatTypeValidationError" }

// Error satisfies the builtin error interface
func (e RicFormatTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicFormatType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicFormatTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicFormatTypeValidationError{}

// Validate checks the field values on RicEventTriggerStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicEventTriggerStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicEventTriggerStyleItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicEventTriggerStyleItemMultiError, or nil if none found.
func (m *RicEventTriggerStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicEventTriggerStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicEventTriggerFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicEventTriggerStyleItemValidationError{
					field:  "RicEventTriggerFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicEventTriggerFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicEventTriggerStyleItemValidationError{
				field:  "RicEventTriggerFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicEventTriggerStyleItemMultiError(errors)
	}

	return nil
}

// RicEventTriggerStyleItemMultiError is an error wrapping multiple validation
// errors returned by RicEventTriggerStyleItem.ValidateAll() if the designated
// constraints aren't met.
type RicEventTriggerStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicEventTriggerStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicEventTriggerStyleItemMultiError) AllErrors() []error { return m }

// RicEventTriggerStyleItemValidationError is the validation error returned by
// RicEventTriggerStyleItem.Validate if the designated constraints aren't met.
type RicEventTriggerStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicEventTriggerStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicEventTriggerStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicEventTriggerStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicEventTriggerStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicEventTriggerStyleItemValidationError) ErrorName() string {
	return "RicEventTriggerStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicEventTriggerStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicEventTriggerStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicEventTriggerStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicEventTriggerStyleItemValidationError{}

// Validate checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RicReportStyleItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RicReportStyleItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RicReportStyleItemMultiError, or nil if none found.
func (m *RicReportStyleItem) ValidateAll() error {
	return m.validate(true)
}

func (m *RicReportStyleItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRicReportStyleType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicReportStyleName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicReportStyleName",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicReportStyleName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicReportStyleName",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicActionFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicActionFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicActionFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicActionFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasInfoActionList()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "MeasInfoActionList",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasInfoActionList()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "MeasInfoActionList",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationHeaderFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationHeaderFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationHeaderFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationHeaderFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRicIndicationMessageFormatType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RicReportStyleItemValidationError{
					field:  "RicIndicationMessageFormatType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRicIndicationMessageFormatType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RicReportStyleItemValidationError{
				field:  "RicIndicationMessageFormatType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RicReportStyleItemMultiError(errors)
	}

	return nil
}

// RicReportStyleItemMultiError is an error wrapping multiple validation errors
// returned by RicReportStyleItem.ValidateAll() if the designated constraints
// aren't met.
type RicReportStyleItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RicReportStyleItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RicReportStyleItemMultiError) AllErrors() []error { return m }

// RicReportStyleItemValidationError is the validation error returned by
// RicReportStyleItem.Validate if the designated constraints aren't met.
type RicReportStyleItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RicReportStyleItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RicReportStyleItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RicReportStyleItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RicReportStyleItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RicReportStyleItemValidationError) ErrorName() string {
	return "RicReportStyleItemValidationError"
}

// Error satisfies the builtin error interface
func (e RicReportStyleItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRicReportStyleItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RicReportStyleItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RicReportStyleItemValidationError{}

// Validate checks the field values on E2SmXTddControlHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddControlHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddControlHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmXTddControlHeaderMultiError, or nil if none found.
func (m *E2SmXTddControlHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddControlHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmXtddControlHeader.(type) {

	case *E2SmXTddControlHeader_ControlHeaderFormat1:

		if all {
			switch v := interface{}(m.GetControlHeaderFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddControlHeaderValidationError{
						field:  "ControlHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddControlHeaderValidationError{
						field:  "ControlHeaderFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetControlHeaderFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddControlHeaderValidationError{
					field:  "ControlHeaderFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmXTddControlHeaderMultiError(errors)
	}

	return nil
}

// E2SmXTddControlHeaderMultiError is an error wrapping multiple validation
// errors returned by E2SmXTddControlHeader.ValidateAll() if the designated
// constraints aren't met.
type E2SmXTddControlHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddControlHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddControlHeaderMultiError) AllErrors() []error { return m }

// E2SmXTddControlHeaderValidationError is the validation error returned by
// E2SmXTddControlHeader.Validate if the designated constraints aren't met.
type E2SmXTddControlHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddControlHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddControlHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddControlHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddControlHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddControlHeaderValidationError) ErrorName() string {
	return "E2SmXTddControlHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddControlHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddControlHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddControlHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddControlHeaderValidationError{}

// Validate checks the field values on E2SmXTddControlHeaderFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddControlHeaderFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddControlHeaderFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmXTddControlHeaderFormat1MultiError, or nil if none found.
func (m *E2SmXTddControlHeaderFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddControlHeaderFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RcCommand

	if len(errors) > 0 {
		return E2SmXTddControlHeaderFormat1MultiError(errors)
	}

	return nil
}

// E2SmXTddControlHeaderFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmXTddControlHeaderFormat1.ValidateAll() if
// the designated constraints aren't met.
type E2SmXTddControlHeaderFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddControlHeaderFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddControlHeaderFormat1MultiError) AllErrors() []error { return m }

// E2SmXTddControlHeaderFormat1ValidationError is the validation error returned
// by E2SmXTddControlHeaderFormat1.Validate if the designated constraints
// aren't met.
type E2SmXTddControlHeaderFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddControlHeaderFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddControlHeaderFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddControlHeaderFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddControlHeaderFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddControlHeaderFormat1ValidationError) ErrorName() string {
	return "E2SmXTddControlHeaderFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddControlHeaderFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddControlHeaderFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddControlHeaderFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddControlHeaderFormat1ValidationError{}

// Validate checks the field values on E2SmXTddControlMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddControlMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddControlMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// E2SmXTddControlMessageMultiError, or nil if none found.
func (m *E2SmXTddControlMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddControlMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.E2SmXtddControlMessage.(type) {

	case *E2SmXTddControlMessage_ControlMessageFormat1:

		if all {
			switch v := interface{}(m.GetControlMessageFormat1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, E2SmXTddControlMessageValidationError{
						field:  "ControlMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, E2SmXTddControlMessageValidationError{
						field:  "ControlMessageFormat1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetControlMessageFormat1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return E2SmXTddControlMessageValidationError{
					field:  "ControlMessageFormat1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return E2SmXTddControlMessageMultiError(errors)
	}

	return nil
}

// E2SmXTddControlMessageMultiError is an error wrapping multiple validation
// errors returned by E2SmXTddControlMessage.ValidateAll() if the designated
// constraints aren't met.
type E2SmXTddControlMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddControlMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddControlMessageMultiError) AllErrors() []error { return m }

// E2SmXTddControlMessageValidationError is the validation error returned by
// E2SmXTddControlMessage.Validate if the designated constraints aren't met.
type E2SmXTddControlMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddControlMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddControlMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddControlMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddControlMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddControlMessageValidationError) ErrorName() string {
	return "E2SmXTddControlMessageValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddControlMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddControlMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddControlMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddControlMessageValidationError{}

// Validate checks the field values on ControlElement with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ControlElement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ControlElement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ControlElementMultiError,
// or nil if none found.
func (m *ControlElement) ValidateAll() error {
	return m.validate(true)
}

func (m *ControlElement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetValue()); l < 1 || l > 150 {
		err := ControlElementValidationError{
			field:  "Value",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ControlElementMultiError(errors)
	}

	return nil
}

// ControlElementMultiError is an error wrapping multiple validation errors
// returned by ControlElement.ValidateAll() if the designated constraints
// aren't met.
type ControlElementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ControlElementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ControlElementMultiError) AllErrors() []error { return m }

// ControlElementValidationError is the validation error returned by
// ControlElement.Validate if the designated constraints aren't met.
type ControlElementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ControlElementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ControlElementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ControlElementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ControlElementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ControlElementValidationError) ErrorName() string { return "ControlElementValidationError" }

// Error satisfies the builtin error interface
func (e ControlElementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sControlElement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ControlElementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ControlElementValidationError{}

// Validate checks the field values on E2SmXTddControlMessageFormat1 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *E2SmXTddControlMessageFormat1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on E2SmXTddControlMessageFormat1 with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// E2SmXTddControlMessageFormat1MultiError, or nil if none found.
func (m *E2SmXTddControlMessageFormat1) ValidateAll() error {
	return m.validate(true)
}

func (m *E2SmXTddControlMessageFormat1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCe1()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddControlMessageFormat1ValidationError{
					field:  "Ce1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddControlMessageFormat1ValidationError{
					field:  "Ce1",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCe1()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddControlMessageFormat1ValidationError{
				field:  "Ce1",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCe2()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, E2SmXTddControlMessageFormat1ValidationError{
					field:  "Ce2",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, E2SmXTddControlMessageFormat1ValidationError{
					field:  "Ce2",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCe2()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return E2SmXTddControlMessageFormat1ValidationError{
				field:  "Ce2",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return E2SmXTddControlMessageFormat1MultiError(errors)
	}

	return nil
}

// E2SmXTddControlMessageFormat1MultiError is an error wrapping multiple
// validation errors returned by E2SmXTddControlMessageFormat1.ValidateAll()
// if the designated constraints aren't met.
type E2SmXTddControlMessageFormat1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m E2SmXTddControlMessageFormat1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m E2SmXTddControlMessageFormat1MultiError) AllErrors() []error { return m }

// E2SmXTddControlMessageFormat1ValidationError is the validation error
// returned by E2SmXTddControlMessageFormat1.Validate if the designated
// constraints aren't met.
type E2SmXTddControlMessageFormat1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e E2SmXTddControlMessageFormat1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e E2SmXTddControlMessageFormat1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e E2SmXTddControlMessageFormat1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e E2SmXTddControlMessageFormat1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e E2SmXTddControlMessageFormat1ValidationError) ErrorName() string {
	return "E2SmXTddControlMessageFormat1ValidationError"
}

// Error satisfies the builtin error interface
func (e E2SmXTddControlMessageFormat1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sE2SmXTddControlMessageFormat1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = E2SmXTddControlMessageFormat1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = E2SmXTddControlMessageFormat1ValidationError{}
